{"meta":{"title":"初见","subtitle":null,"description":null,"author":"zheng","url":"https://github.com/zheng521","root":"/"},"pages":[],"posts":[{"title":"重载","slug":"重载","date":"2023-07-09T06:30:00.000Z","updated":"2023-07-09T08:25:31.065Z","comments":true,"path":"2023/07/09/重载/","link":"","permalink":"https://github.com/zheng521/2023/07/09/%E9%87%8D%E8%BD%BD/","excerpt":"","text":"重载定义 函数重载（英语：function overloading）或方法重载，是某些编程语言（如 C++、C#、Java、Swift、Kotlin 等）具有的一项特性，该特性允许创建多个具有不同实现的同名函数。对重载函数的调用会运行其适用于调用上下文的具体实现，即允许一个函数调用根据上下文执行不同的任务。 重载规则 多个函数定义使用相同的函数名称 函数参数的数量或类型必须有区别 java 中的重载 重载可以理解成多态的具体表现形式。 在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。 这种方法名相同，但各自的参数不同，称为方法重载（Overload）。 1234567891011121314151617class Hello &#123; public void hello() &#123; System.out.println(&quot;Hello, world!&quot;); &#125; public void hello(String name) &#123; System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;); &#125; public void hello(String name, int age) &#123; if (age &lt; 18) &#123; System.out.println(&quot;Hi, &quot; + name + &quot;!&quot;); &#125; else &#123; System.out.println(&quot;Hello, &quot; + name + &quot;!&quot;); &#125; &#125;&#125; 注意：方法重载的返回值类型通常都是相同的。 方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。 TypeScript 重载JavaScript 作为动态语言， 是没有重载这一说的。一是它的参数没有类型的区分，二是对参数个数也没有检查。虽然语言层面无法自动进行重载，但借助其动态的特性，我们可以在代码中手动检查入参的类型，或者通过 arguments 获取到参数个数，从而实现根据不同的入参做不同的操作。 重载的理解用于实现不同参数输入并且对应不同参数输出的函数，在前面定义多个重载签名，一个实现签名，一个函数体构造，重载签名主要是精确显示函数的输入输出，实现签名主要是将所有的输入输出类型做一个全量定义，防止TS编译报错，函数体就是整个整个函数实现的全部逻辑。 函数重载12345678910111213141516171819202122232425function padding(all: number)function padding(topAndBottom: number, leftAndRight: number)function padding(top: number, right: number, bottom: number, left: number)// 1/实际的函数体应该包含函数重载的所有情况function padding(a: number, b?: number, c?: number, d?: number) &#123; if (b === undefined &amp;&amp; c === undefined &amp;&amp; d === undefined) &#123; b = c = d = a &#125; else if (c === undefined &amp;&amp; d === undefined) &#123; c = a d = b &#125; return &#123; top: a, right: b, bottom: c, left: d, &#125;&#125;padding (1); // 正确： all// 匹配第 1个重载padding (1, 1); // 正确： topAndBottom, leftAndRight// 匹配第 2个重载padding (1, 1, 1, 1)； //正确：top、 right, bottom, left// 匹配第3个重载padding (1, 1, 1) //错误： Not a part of the available overloads 注意：Typescript 中的西数重载没有任何运行时的开销。它只允许记录你希望的调用函数的方式，并且编译器会检查其余代码. 通过鼠标点击实际调用方法 padding(1),command+鼠标右键，他会自动解析跳转到number这个重载签名上面去，很直观的知道如何调用的。 重载过程TypeScript 重载的过程是，拿传入的参数和重载的方法签名列表中由上往下逐个匹配，直到找到一个完全匹配的函数签名，否则报错。所以推荐的做法是将签名更加具体的重载放上面，不那么具体的放后面。 12345678// good function getMessage(type: MessageType, count?: number): Message[];function getMessage(id: number): Message | undefined;//bad function getMessage(id: number): Message | undefined;function getMessage(type: MessageType, count?: number): Message[]; 方法重载1234567891011121314151617181920 class ArrayEN &#123; constructor(public arr: object[]) &#123;&#125; get(Index: number) &#123; return this.arr[Index]; &#125; delete(value: number): number; delete(value: object): object; delete(value: number | object): number | object &#123; this.arr = this.arr.filter((item, index) =&gt; &#123; if (typeof value === &quot;number&quot;) &#123; return value !== index; &#125; else &#123; return value !== item; &#125; &#125;); return value; &#125;&#125; 构造器重载构造器是没有返回值的，他会隐式返回一个this，这个this会分配给new对象的左边的变量，至此所有的this都是指向的当前正在使用的对象。构造器重载和函数重载使基本相同，主要区别是：TS 类构造器重载签名和实现签名都不需要管理返回值，TS 构造器是在对象创建出来之后，但是还没有赋值给对象变量之前被执行，一般用来给对象属性赋值。 1234567891011121314151617181920212223242526272829 interface OJType&#123; width?:number, height?:number&#125;class Graph&#123; public width:number; public height:number; constructor(width?:number,height?:number) constructor(side?:OJType) constructor(v1:any,v2?:any)&#123; if(typeof v1===&#x27;object&#x27;)&#123; this.width=v1.width; this.height=v1.height &#125;else&#123; this.width=v1; this.height=v2; &#125; &#125; getArea()&#123; const &#123;width,height&#125;=this; return width*height &#125;&#125;const g=new Graph(10,10);console.log(g.getArea()) 扩散重写 方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。","categories":[],"tags":[]},{"title":"react基础","slug":"react基础","date":"2023-04-05T02:42:06.000Z","updated":"2023-04-06T06:14:15.968Z","comments":true,"path":"2023/04/05/react基础/","link":"","permalink":"https://github.com/zheng521/2023/04/05/react%E5%9F%BA%E7%A1%80/","excerpt":"","text":"react 生命周期 constructor⏱ 触发时机：在组件初始化的时候触发一次。💡 使用建议： 设置初始化状态：因为组件的生命周期中任何函数都可能要访问 State，那么整个周期中第一个被调用的构造函数便是初始化 state 最理想的地方； 绑定成员函数上下文引用： 因为在 ES6 语法下，类的每个成员函数在执行时的 this 并不是和类实例自动绑定的； 而在构造函数中 this 就是当前组件实例，所以，为了方便将来调用，往往在构造函数中将这个实例的特定函数绑定 this 为当前类实例； 建议定义函数方法时直接使用箭头函数，就无须在构造函数中进行函数的 bind 操作。 static getDerivedStateFromProps⏱ 触发时机：该函数会在组件化实例化后和重新渲染前调用（生成 VirtualDOM 之后，实际 DOM 挂载之前），意味着无论是父组件的更新、props 的变化或通过 setState 更新组件内部的 State，它都会被调用。 🔙 返回值：该生命周期函数必须有返回值，它需要返回一个对象来更新 State，或者返回 null 来表明新 props 不需要更新任何 state。 🆕 新特性：当组件实例化时，该方法替代了 componentWillMount，而当接收新的 props 时，该方法替代了 componentWillReceiveProps 和 componentWillUpdate。 ⚠️ 注意事项： 在组件装载和更新阶段都会触发。 如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被触发； 如果你只想处理 props 的前后变化，你需要将上一个 props 值存到 state 里作为镜像； 该生命周期函数是一个静态函数，所以函数体内无法访问指向当前组件实例的指针 this；当需要更新 state 时，需要返回一个对象，否则，返回一个 null render它是一个仅仅用于渲染的纯函数，返回值完全取决于 state 和 props，不能在函数中任何修改 state、props、请求数据等具有副作用的操作，不能读写 DOM 信息，也不能和浏览器进行交互（例如 setTimeout）。如果需要和浏览器交互，在 componentDidMount() 中或者其它生命周期方法完成相关事务。 ⚠️ 注意事项： 请勿在此函数中使用 setState 方法； 请勿在此函数中修改 props、state 以及数据请求等具有副作用的操作。 componentDidMount⏱ 触发时机：组件完全挂载到网页上后触发。 🎉 适用场景：发送网络请求；任何依赖于 DOM 的初始化操作；添加事件监听；如果使用了 Redux 之类的数据管理工具，也能触发 action 处理数据变化逻辑。 🔬深入研究：该函数不会在 render 函数调用完成之后立即触发，因为 render 函数仅仅是返回了 JSX 的对象，并没有立即挂载到 DOM 树上，而该生命周期函数是在组件被渲染到 DOM 树（称为初始化渲染）之后触发的。 ⚠️ 注意事项：该生命周期函数在进行服务器端渲染时不会触发（仅客户端有效）。 shouldComponentUpdate⏱ 触发时机：每次组件因为 state 和 props 变化而更新时，在重新渲染前该生命周期函数都会触发，让 React 知道当前 state 或 props 的改变是否影响组件的输出（渲染）。 🔙 返回值：根据逻辑判断返回 true 表示继续进行组件渲染，否则将停止组件渲染过程。默认返回 true，也就是说，只要组件触发了更新，组件就一定会更新。 🔬深入研究：在一个更新生命周期中，组件及其子组件将根据该方法返回的布尔值来决定是否继续这次更新过程（重新渲染）。这样你可以在必要的时候阻止组件的渲染生命周期（Render Lifecycle）方法，避免不必要的渲染。 ⚠️ 注意事项： 此钩子函数在初始化渲染和使用了 forceUpdate 方法的情况下不会被触发，使用 forceUpdate 会强制更新 请勿在此函数中使用 setState 方法，会导致循环调用。 getSnapshotBeforeUpdate⏱ 触发时机：该生命周期函数会在组件即将挂载时触发，它的触发在 render 渲染函数之后。由此可见，render 函数并没有完成挂载操作，而是进行构建抽象 UI（也就是 Virtual DOM）的工作。该生命周期函数执行完毕后就会立即触发 componentDidUpdate 生命周期钩子。 🎉 适用场景：该生命周期函数能让你捕获某些从 DOM 中才能获取的（可能会变更的）信息（例如，元素重新渲染后页面各种定位位置的变更等）。 作用：比如网页滚动位置，不需要它持久化，只需要在组件更新以后能够恢复原来的位置即可。 ⚠️ 注意事项： 该生命周期函数返回的值将作为第三个参数传递给 componentDidUpdate，我们可以利用这个通道保存一些不需要持久化的状态，用完即可舍弃。（这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。） 该函数的出现是为了 React 17 的异步渲染而准备的 componentDidUpdate⏱ 触发时机：组件每次重新渲染后触发，相当于首次渲染（初始化）之后触发 componentDidMount ， 🎉 适用场景：操作 DOM；发送网络请求。 ⚠️ 注意事项： 将原先写在 componentWilUpdate 中的回调迁移至 componentDidUpdate，将以前放在 componentWillReceiveProps 中的异步网络请求放在 componentDidUpdate 中。 在该生命周期中使用 setState 时，必须加 if 条件判断，通过判断 prevProps、prevState 和 this.state 之间的数据变化，来判断是否执行相关的 state 变更逻辑，这使得尽管在 componentDidUpdate 中调用了 setState 进行再更新，但是直至条件不成立，就不会造成程序死循环。 此生命周期函数不会在初始化渲染的时候触发。 componentWillUnmount⏱ 触发时机：在组件卸载和销毁之前触发。可以利用这个生命周期方法去执行任何清理任务。 🎉 适用场景：用于注销事件监听器；取消网络请求；取消定时器；解绑 DOM 事件。 ⚠️ 注意事项：在该方法中调用 setState 不会触发 render，因为所有的更新队列，更新状态都被重置为 null。 static getDerivedStateFromError⏱ 触发时机：该生命周期函数会在子孙组件抛出错误时执行。 🔙 返回值：它接收抛出的错误作为参数并且需要返回值用于更新 State。 💡 使用建议： 该生命周期函数中可用于修改 state 以显示错误提醒的 UI，或者将错误信息发送到服务端进行 Log 用于后期分析； 在捕获到错误的瞬间，React 会在这次渲染周期中将这个组件渲染为 null，这就有可能导致他的父组件设置他上面的 ref 获得 null 而导致一些问题； componentDidCatch ⏱ 触发时机：该生命周期函数会在子孙组件抛出错误时触发。 ⚠️ 注意事项：错误边界只能捕捉生命周期中的错误（componentWillMount &#x2F; render 等方法在内）。无法捕捉异步、事件回调中的错误，要捕捉和覆盖所有场景依然需要配合 window.onerror、Promise.catch、try&#x2F;catch 等方式。 父子生命周期首次渲染过程1父constructor-&gt;父getDerivedStateFromProps-&gt;父renders-&gt;子constructor-&gt;子getDerivedStateFromProps-&gt;子renders-&gt;子componentDidMount-&gt;父componentDidMount 更新过程1父getDerivedStateFromPops-&gt;父shouldComponentUpdate-&gt;父render-&gt;子getDerivedStateFromPops-&gt;子shouldComponentUpdate-&gt;子render-&gt;子getSnapshotBeforeUpdate-&gt;父getSnapshotBeforeUpdate-&gt;子componentDidUpdate-&gt;父子componentDidUpdate 卸载过程1父getDerivedStateFromPops-&gt;父shouldComponentUpdate-&gt;父render-&gt;父getSnapshotBeforeUpdate-&gt;子componentWillUnmount-&gt;父componentDidUpdate 父子组件生命周期执行顺序总结： 当子组件自身状态改变时，不会对父组件产生副作用的情况下，父组件不会进行更新，即不会触发父组件的生命周期 当父组件中状态发生变化（包括子组件的挂载以及卸载）时，会触发自身对应的生命周期以及子组件的更新 render 以及 render 之前的生命周期，则 父组件先执行 render 之后的声明周期，则子组件先执行，并且是与父组件交替执行 当子组件进行卸载时，只会执行自身的 componentWillUnmount 生命周期，不会再触发别的生命周期 react 优化 循环使用 key 修改 css 模拟 v-show 使用 Fragment 减少层级 JSX 中不要定义函数 在构造函数 bind this 使用 shouldComponentUpdate 控制组件渲染 React.memo 缓存函数组件 useMemo 缓存数据 异步组件 路由懒加载 SSR react遇到的坑 JSX 中，自定义组件命名，开头字母要大写，html 标签开头字母小写 JSX 中 for 写成 htmlFor ， class 写成 className state 作为不可变数据，不可直接修改，使用纯函数 JSX 中，属性要区分 JS 表达式和字符串12&lt;Demo position=&#123;1&#125; flag=&#123;true&#125;/&gt;&lt;Demo position=&quot;1&quot; flag=&quot;true&quot;/&gt; state 是异步更新的，要在 callback 中拿到最新的 state 值React Hooks 有很多限制，注意不到就会踩坑。例如，useEffect 内部不能修改 state 123456789101112131415function App() &#123; const [count, setCount] = useState(0) useEffect(() =&gt; &#123; const timer = setInterval(() =&gt; &#123; setCount(count + 1) // 如果依赖是 [] ，这里 setCount 不会成功 &#125;, 1000) return () =&gt; clearTimeout(timer) &#125;, [count]) // 只有依赖是 [count] 才可以，这样才会触发组件 update return &lt;div&gt;count: &#123;count&#125;&lt;/div&gt;&#125;export default App 再例如，useEffect 依赖项（即第二个参数）里有对象、数组，就会出现死循环。所以，依赖项里都要是值类型。因为 React Hooks 是通过 Object.is 进行依赖项的前后比较。如果是值类型，则不妨碍。如果是引用类型，前后的值是不一样的（纯函数，每次新建值），就类似 &#123;x:100&#125; !== &#123;x:100&#125; 123useEffect(() =&gt; &#123; // ...&#125;, [obj, arr]) React 错误监听 ErrorBoundary","categories":[],"tags":[]},{"title":"vue基础","slug":"vue基础","date":"2023-04-05T02:41:49.000Z","updated":"2023-04-06T05:59:20.293Z","comments":true,"path":"2023/04/05/vue基础/","link":"","permalink":"https://github.com/zheng521/2023/04/05/vue%E5%9F%BA%E7%A1%80/","excerpt":"","text":"vue 生命周期 beforeCreate初始化一个空的 Vue 实例，data methods 等尚未被初始化，无法调用。 createdVue 实例初始化完成，data methods 都已初始化完成，可调用。但尚未开始渲染模板。 beforeMount编译模板，调用 render 函数生成 vdom ，但还没有开始渲染 DOM mounted渲染 DOM 完成，页面更新。组件创建完成，开始进入运行阶段。 beforeUpdate在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。 updated在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。 注意，尽量不要在 updated 中继续修改数据，否则可能会触发死循环。 onActivated被 keep-alive 缓存的组件激活时调用。 onDeactivated被 keep-alive 缓存的组件停用时调用。 beforeUnmount组件进入销毁阶段。 卸载组件实例后调用，在这个阶段，实例仍然是完全正常的。移除、解绑一些全局事件、自定义事件，可以在此时操作。 unmounted卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。 连环问：如何正确的操作 DOMmounted 和 updated 都不会保证所有子组件都挂载完成，如果想等待所有视图都渲染完成，需要使用 $nextTick 12345mounted() &#123; this.$nextTick(function () &#123; // 仅在整个视图都被渲染之后才会运行的代码 &#125;)&#125; 连环问：ajax 放在哪个生命周期合适？一般有两个选择：created 和 mounted ，建议选择后者 mounted 。 执行速度 从理论上来说，放在 created 确实会快一些 但 ajax 是网络请求，其时间是主要的影响因素。从 created 到 mounted 是 JS 执行，速度非常快。 所以，两者在执行速度上不会有肉眼可见的差距 代码的阅读和理解 放在 created 却会带来一些沟通和理解成本，从代码的执行上来看，它会一边执行组件渲染，一边触发网络请求，并行 放在 mounted 就是等待 DOM 渲染完成再执行网络请求，串行，好理解 所以，综合来看，更建议选择 mounted 。 连环问：Composition API 生命周期有何不同 setup 代替了 beforeCreate 和 created 生命周期换成了函数的形式，如 mounted -&gt; onMounted 参考 https://v3.cn.vuejs.org/api/composition-api.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90 123456789101112import &#123; onUpdated, onMounted &#125; from &#x27;vue&#x27;export default &#123; setup() &#123; onMounted(() =&gt; &#123; console.log(&#x27;mounted&#x27;) &#125;) onUpdated(() =&gt; &#123; console.log(&#x27;updated&#x27;) &#125;) &#125; &#125; 父子生命周期流程加载渲染过程1父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted 更新过程1父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated 销毁过程1父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed Vue 优化 v-if 和 v-show v-for 使用 key computed 缓存 keep-alive 异步组件 路由懒加载 SSR Vue遇到的坑全局事件、自定义事件要在组件销毁时解除绑定 内存泄漏风险 全局事件（如 window.resize）不解除，则会继续监听，而且组件再次创建时会重复绑定 Vue2.x 中，无法监听 data 属性的新增和删除，以及数组的部分修改 —— Vue3 不会有这个问题 新增 data 属性，需要用 Vue.set 删除 data 属性，需要用 Vue.delete 修改数组某一元素，不能 arr[index] = value ，要使用 arr.splice API 方式 路由切换时，页面会 scroll 到顶部。例如，在一个新闻列表页下滑到一定位置，点击进入详情页，在返回列表页，此时会 scroll 到顶部，并重新渲染列表页。所有的 SPA 都会有这个问题，并不仅仅是 Vue 。 在列表页缓存数据和 scrollTop 返回列表页时（用 Vue-router 导航守卫，判断 from），使用缓存数据渲染页面，然后 scrollTo(scrollTop) Vue 错误监听 window.onerror errorCaptured 生命周期 会监听所有下级组件的错误。可以返回 false 阻止向上传播，因为可能会有多个上级节点都监听错误。 123errorCaptured(error, instance, info) &#123; console.log(&#x27;errorCaptured--------&#x27;, error, instance, info)&#125; errorHandler 全局的错误监听，所有组件的报错都会汇总到这里来。PS：如果 errorCaptured 返回 false 则不会到这里。 1234const app = createApp(App)app.config.errorHandler = (error, instance, info) =&gt; &#123; console.log(&#x27;errorHandler--------&#x27;, error, instance, info)&#125; 请注意，errorHandler 会阻止错误走向 window.onerror。 Promise 监听报错要使用 window.onunhandledrejection","categories":[],"tags":[]},{"title":"前端基础","slug":"前端基础","date":"2023-04-04T14:14:21.000Z","updated":"2023-04-06T06:27:14.044Z","comments":true,"path":"2023/04/04/前端基础/","link":"","permalink":"https://github.com/zheng521/2023/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"箭头函数的缺点题目什么时候不能使用箭头函数？ 箭头函数的缺点没有 arguments 1234const fn1 = () =&gt; &#123; console.log(&#x27;this&#x27;, arguments) // 报错，arguments is not defined&#125;fn1(100, 200) 无法通过 call apply bind 等改变 this 1234const fn1 = () =&gt; &#123; console.log(&#x27;this&#x27;, this) // window&#125;fn1.call(&#123; x: 100 &#125;) 简写的函数会变得难以阅读 1const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b 不适用箭头函数的场景对象方法 1234567const obj = &#123; name: &#x27;张三&#x27;, getName: () =&gt; &#123; return this.name &#125;&#125;console.log( obj.getName() ) 扩展对象原型（包括构造函数的原型） 1234567const obj = &#123; name: &#x27;张三&#x27;&#125;obj.__proto__.getName = () =&gt; &#123; return this.name&#125;console.log( obj.getName() ) 构造函数 12345const Foo = (name, age) =&gt; &#123; this.name = name this.age = age&#125;const f = new Foo(&#x27;张三&#x27;, 20) // 报错 Foo is not a constructor 动态上下文中的回调函数 12345const btn1 = document.getElementById(&#x27;btn1&#x27;)btn1.addEventListener(&#x27;click&#x27;, () =&gt; &#123; // console.log(this === window) this.innerHTML = &#x27;clicked&#x27;&#125;) Vue 生命周期和方法 12345678910111213141516171819&#123; data() &#123; return &#123; name: &#x27;张三&#x27; &#125; &#125;, methods: &#123; getName: () =&gt; &#123; // 报错 Cannot read properties of undefined (reading &#x27;name&#x27;) return this.name &#125;, // getName() &#123; // return this.name // 正常 // &#125; &#125;, mounted: () =&gt; &#123; // 报错 Cannot read properties of undefined (reading &#x27;name&#x27;) console.log(&#x27;msg&#x27;, this.name) &#125;, // mounted() &#123; // console.log(&#x27;msg&#x27;, this.name) // 正常 // &#125;&#125; 【注意】class 中使用箭头函数则没问题 1234567891011class Foo &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; getName = () =&gt; &#123; return this.name &#125;&#125;const f = new Foo(&#x27;张三&#x27;, 20)console.log(&#x27;getName&#x27;, f.getName()) 所以，在 React 中可以使用箭头函数 1234567891011121314export default class HelloWorld extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: &#x27;张三&#x27; &#125; &#125; render() &#123; return &lt;p onClick=&#123;this.printName&#125;&gt;hello world&lt;/p&gt; &#125; printName = () =&gt; &#123; console.log(this.state.name) &#125;&#125; 答案箭头函数的缺点 arguments 参数 无法改变 this 不适用的场景 对象方法 对象原型 构造函数 动态上下文 Vue 生命周期和方法 for…in 和 for…of 的区别题目for…in 和 for…of 的区别 key 和 valuefor…in 遍历 key , for…of 遍历 value 123456789const arr = [10, 20, 30]for (let n of arr) &#123; console.log(n)&#125;const str = &#x27;abc&#x27;for (let s of str) &#123; console.log(s)&#125; 1234567891011function fn() &#123; for (let argument of arguments) &#123; console.log(argument) // for...of 可以获取 value ，而 for...in 获取 key &#125;&#125;fn(10, 20, 30)const pList = document.querySelectorAll(&#x27;p&#x27;)for (let p of pList) &#123; console.log(p) // for...of 可以获取 value ，而 for...in 获取 key&#125; 遍历对象for…in 可以遍历对象，for…of 不可以 遍历 Map&#x2F;Setfor…of 可以遍历 Map&#x2F;Set ，for…in 不可以 1234567891011const set1 = new Set([10, 20, 30])for (let n of set1) &#123; console.log(n)&#125;let map1 = new Map([ [&#x27;x&#x27;, 10], [&#x27;y&#x27;, 20], [&#x27;z&#x27;, 3]])for (let n of map1) &#123; console.log(n)&#125; 遍历 generatorfor…of 可遍历 generator ，for…in 不可以 12345678function* foo()&#123; yield 10 yield 20 yield 30&#125;for (let o of foo()) &#123; console.log(o)&#125; 对象的可枚举属性for…in 遍历一个对象的可枚举属性。 使用 Object.getOwnPropertyDescriptors(obj) 可以获取对象的所有属性描述，看 enumerable: true 来判断该属性是否可枚举。 对象，数组，字符传 可迭代对象for…of 遍历一个可迭代对象。其实就是迭代器模式，通过一个 next 方法返回下一个元素。 该对象要实现一个 [Symbol.iterator] 方法，其中返回一个 next 函数，用于返回下一个 value（不是 key）。可以执行 arr[Symbol.iterator]() 看一下。 JS 中内置迭代器的类型有 String Array arguments NodeList Map Set generator 等。 答案 for…in 遍历一个对象的可枚举属性，如对象、数组、字符串。针对属性，所以获得 key for…of 遍历一个可迭代对象，如数组、字符串、Map&#x2F;Set 。针对一个迭代对象，所以获得 value 划重点“枚举” “迭代” 都是计算机语言的一些基础术语，目前搞不懂也没关系。但请一定记住 for…of 和 for…in 的不同表现。 连环问：for await…of用于遍历异步请求的可迭代对象。 12345678// 像定义一个创建 promise 的函数function createTimeoutPromise(val) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(val) &#125;, 1000) &#125;)&#125; 如果你明确知道有几个 promise 对象，那直接处理即可 123456789(async function () &#123; const p1 = createTimeoutPromise(10) const p2 = createTimeoutPromise(20) const v1 = await p1 console.log(v1) const v2 = await p2 console.log(v2)&#125;)() 如果你有一个对象，里面有 N 个 promise 对象，你可以这样处理 12345678910111213141516(async function () &#123; const list = [ createTimeoutPromise(10), createTimeoutPromise(20) ] // 第一，使用 Promise.all 执行 Promise.all(list).then(res =&gt; console.log(res)) // 第二，使用 for await ... of 遍历执行 for await (let p of list) &#123; console.log(p) &#125; // 注意，如果用 for...of 只能遍历出各个 promise 对象，而不能触发 await 执行&#125;)() 【注意】如果你想顺序执行，只能延迟创建 promise 对象，而不能及早创建。即，你创建了 promise 对象，它就立刻开始执行逻辑。 1234567891011(async function () &#123; const v1 = await createTimeoutPromise(10) console.log(v1) const v2 = await createTimeoutPromise(20) console.log(v2) for (let n of [100, 200]) &#123; const v = await createTimeoutPromise(n) console.log(&#x27;v&#x27;, v) &#125;&#125;)() HTMLCollection 和 NodeList 的区别题目HTMLCollection 和 NodeList 的区别，Node 和 Element 的区别 Node 和 ElementDOM 结构是一棵树，树的所有节点都是 Node ，包括：document，元素，文本，注释，fragment 等 Element 继承于 Node 。它是所有 html 元素的基类，如 HTMLParagraphElement HTMLDivElement 1234567891011121314151617class Node &#123;&#125;// documentclass Document extends Node &#123;&#125;class DocumentFragment extends Node &#123;&#125;// 文本和注释class CharacterData extends Node &#123;&#125;class Comment extends CharacterData &#123;&#125;class Text extends CharacterData &#123;&#125;// elemclass Element extends Node &#123;&#125;class HTMLElement extends Element &#123;&#125;class HTMLParagraphElement extends HTMLElement &#123;&#125;class HTMLDivElement extends HTMLElement &#123;&#125;// ... 其他 elem ... HTMLCollection 和 NodeListHTMLCollection 是 Element 集合，它由获取 Element 的 API 返回 elem.children document.getElementsByTagName(&#39;p&#39;) NodeList 是 Node 集合，它由获取 Node 的 API 返回 document.querySelectorAll(&#39;p&#39;) elem.childNodes 答案 HTMLCollection 是 Element 集合，NodeList 是 Node 集合 Node 是所有 DOM 节点的基类，Element 是 html 元素的基类 划重点注意 Node 和 Element 在实际 API 中的区别，如 children 和 childNodes 获取的结果可能是不一样的（如果子节点有 Text 或 Comment） 扩展：类数组HTMLCollection 和 NodeList 都不是数组，而是“类数组”。转换为数组： 1234// HTMLCollection 和 NodeList 都不是数组，而是“类数组”const arr1 = Array.from(list)const arr2 = Array.prototype.slice.call(list)const arr3 = [...list] JS 严格模式和非严格模式题目JS 严格模式和非严格模式的区别 设计初衷Javascript 设计之初，有很多不合理、不严谨、不安全之处，例如变量未定义即可使用 n = 100。严格模式用于规避这些问题。 而现在 ES 规范已经普及，从语法上已经规避了这些问题。 开启严格模式代码（或一个函数）一开始插入一行 &#39;use strict&#39; 即可开启严格模式 123456&#x27;use strict&#x27; // 全局开启function fn() &#123; &#x27;use strict&#x27; // 某个函数开启&#125; 一般情况下，开发环境用 ES 或者 Typescript ，打包出的 js 代码使用严格模式 严格模式的不同严格模式的细则有很多，这里总结一些常用常见的 全局变量必须声明12&#x27;use strict&#x27;n = 10 // ReferenceError: n is not defined 禁止使用 with123456&#x27;use strict&#x27;var obj = &#123; x: 10 &#125;with (obj) &#123; // Uncaught SyntaxError: Strict mode code may not include a with statement console.log(x)&#125; 创建 eval 作用域正常模式下，JS 只有两种变量作用域：全局作用域 + 函数作用域。严格模式下，JS 增加了 eval 作用域。 chrome 隐私模式下执行这段代码？？？ 1234&#x27;use strict&#x27;var x = 10eval(&#x27;var x = 20; console.log(x)&#x27;)console.log(x) 禁止 this 指向全局作用域12345&#x27;use strict&#x27;function fn() &#123; console.log(&#x27;this&#x27;, this) // undefined&#125;fn() 函数参数不能重名123456&#x27;use strict&#x27;// Uncaught SyntaxError: Duplicate parameter name not allowed in this contextfunction fn(x, x, y) &#123; return&#125; 答案 全局变量必须声明 禁止使用 with 创建 eval 作用域 禁止 this 指向全局作用域 函数参数不能重名 options 请求题目跨域为何需要 options 请求？ 跨域浏览器同源策略，默认限制跨域请求。跨域的解决方案 jsonp CORS 12345// CORS 配置允许跨域（服务端）response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8011&quot;) // 或者 &#x27;*&#x27;response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;)response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;)response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;) // 允许跨域接收 cookie options 请求使用 CORS 跨域请求时，经常会看到一个“多余”的 options 请求，之后才发送了实际的请求。 该请求就是为了检查服务端的 headers 信息，是否符合客户端的预期。所以它没有 body 的返回。 规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。—— MDN 答案options 请求就是对 CORS 跨域请求之间的一次预检查，检查成功再发起正式请求，是浏览器自行处理的。了解即可，实际开发中不用过于关注。 js 原型链 &#x3D;&#x3D; 比较 数组方法 前端首屏加载优化 https 加密过程","categories":[],"tags":[]},{"title":"输出什么","slug":"输出什么","date":"2023-04-04T13:49:17.000Z","updated":"2023-04-04T14:09:57.469Z","comments":true,"path":"2023/04/04/输出什么/","link":"","permalink":"https://github.com/zheng521/2023/04/04/%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/","excerpt":"","text":"题目[1,2,3].map(parseInt)输出什么 解析parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数 string 要解析的字符串 radix 可选参数，数字基数（即进制），范围为 2-36 示例 1234567891011parseInt(&#x27;11&#x27;, 1) // NaN ，1 非法，不在 2-36 范围之内parseInt(&#x27;11&#x27;, 2) // 3 = 1*2 + 1parseInt(&#x27;3&#x27;, 2) // NaN ，2 进制中不存在 3parseInt(&#x27;11&#x27;, 3) // 4 = 1*3 + 1parseInt(&#x27;11&#x27;, 8) // 9 = 1*8 + 1parseInt(&#x27;9&#x27;, 8) // NaN ，8 进制中不存在 9parseInt(&#x27;11&#x27;, 10) // 11parseInt(&#x27;A&#x27;, 16) // 10 ，超过 10 进制，个位数就是 1 2 3 4 5 6 7 8 9 A B C D ...parseInt(&#x27;F&#x27;, 16) // 15parseInt(&#x27;G&#x27;, 16) // NaN ，16 进制个位数最多是 F ，不存在 GparseInt(&#x27;1F&#x27;, 16) // 31 = 1*16 + F radix &#x3D;&#x3D; null 或者 radix &#x3D;&#x3D;&#x3D; 0 如果 string 以 0x 开头，则按照 16 进制处理，例如 parseInt(&#39;0x1F&#39;) 等同于 parseInt(&#39;1F&#39;, 16) 如果 string 以 0 开头，则按照 8 进制处理 —— ES5 之后就取消了，改为按 10 进制处理，但不是所有浏览器都这样，一定注意！！！ 其他情况，按 10 进制处理 分析代码题目代码可以拆解为 123456const arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]const res = arr.map((s, index) =&gt; &#123; console.log(`s is $&#123;s&#125;, index is $&#123;index&#125;`) return parseInt(s, index)&#125;)console.log(res) 分析执行过程 123parseInt(&#x27;1&#x27;, 0) // 1 ，radix === 0 按 10 进制处理parseInt(&#x27;2&#x27;, 1) // NaN ，radix === 1 非法（不在 2-36 之内）parseInt(&#x27;3&#x27;, 2) // NaN ，2 进制中没有 3 题目以下代码，执行会输出什么？ 1234567891011function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;Foo.prototype.a = function() &#123; console.log(3) &#125;Foo.a = function() &#123; console.log(4) &#125;Foo.a()let obj = new Foo()obj.a()Foo.a() 解析：执行完new以后,函数执行内部函数体会覆盖原来的函数 答案： 4 2 1 题目以下代码，执行会输出什么？ 123456789101112131415161718Promise.resolve().then(() =&gt; &#123; console.log(0) return Promise.resolve(4)&#125;).then((res) =&gt; &#123; console.log(res)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(1)&#125;).then(() =&gt; &#123; console.log(2)&#125;).then(() =&gt; &#123; console.log(3)&#125;).then(() =&gt; &#123; console.log(5)&#125;).then(() =&gt;&#123; console.log(6)&#125;) 解析：then 交替执行如果有多个 fulfilled 状态的 promise 实例，同时执行 then 链式调用，then 会交替调用这是编译器的优化，防止一个 promise 持续占据事件 1234567891011121314151617181920212223242526272829Promise.resolve().then(() =&gt; &#123; console.log(1)&#125;).then(() =&gt; &#123; console.log(2)&#125;).then(() =&gt; &#123; console.log(3)&#125;).then(() =&gt; &#123; console.log(4)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(10)&#125;).then(() =&gt; &#123; console.log(20)&#125;).then(() =&gt; &#123; console.log(30)&#125;).then(() =&gt; &#123; console.log(40)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(100)&#125;).then(() =&gt; &#123; console.log(200)&#125;).then(() =&gt; &#123; console.log(300)&#125;).then(() =&gt; &#123; console.log(400)&#125;) then 返回 promise 对象当 then 返回 promise 对象时，可以认为是多出一个 promise 实例。 123456789101112131415161718192021222324252627282930313233Promise.resolve().then(() =&gt; &#123; console.log(1) return Promise.resolve(100) // 相当于多处一个 promise 实例，如下注释的代码&#125;).then(res =&gt; &#123; console.log(res)&#125;).then(() =&gt; &#123; console.log(200)&#125;).then(() =&gt; &#123; console.log(300)&#125;).then(() =&gt; &#123; console.log(300)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(10)&#125;).then(() =&gt; &#123; console.log(20)&#125;).then(() =&gt; &#123; console.log(30)&#125;).then(() =&gt; &#123; console.log(40)&#125;)// // 相当于新增一个 promise 实例 —— 但这个执行结果不一样，后面解释// Promise.resolve(100).then(res =&gt; &#123;// console.log(res)// &#125;).then(() =&gt; &#123;// console.log(200)// &#125;).then(() =&gt; &#123;// console.log(300)// &#125;).then(() =&gt; &#123;// console.log(400)// &#125;) “慢两拍”then 返回 promise 实例和直接执行 Promise.resolve() 不一样，它需要等待两个过程 promise 状态由 pending 变为 fulfilled then 函数挂载到 microTaskQueue 所以，它变现的会“慢两拍”。可以理解为 123456789101112131415161718192021222324252627282930Promise.resolve().then(() =&gt; &#123; console.log(1)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(10)&#125;).then(() =&gt; &#123; console.log(20)&#125;).then(() =&gt; &#123; console.log(30)&#125;).then(() =&gt; &#123; console.log(40)&#125;)Promise.resolve().then(() =&gt; &#123; // 第一拍 const p = Promise.resolve(100) Promise.resolve().then(() =&gt; &#123; // 第二拍 p.then(res =&gt; &#123; console.log(res) &#125;).then(() =&gt; &#123; console.log(200) &#125;).then(() =&gt; &#123; console.log(300) &#125;).then(() =&gt; &#123; console.log(400) &#125;) &#125;)&#125;) 答案题目代码输出的结果是 1 2 3 4 5 6 题目React 中以下代码会输出什么 12345678910111213141516171819202122232425262728class Example extends React.Component &#123; constructor() &#123; super() this.state = &#123; val: 0 &#125; &#125; componentDidMount() &#123; // this.state.val 初始值是 0 this.setState(&#123;val: this.state.val + 1&#125;) console.log(this.state.val) //0 this.setState(&#123;val: this.state.val + 1&#125;) console.log(this.state.val) //0 setTimeout(() =&gt; &#123; this.setState(&#123;val: this.state.val + 1&#125;) console.log(this.state.val) // 2 this.setState(&#123;val: this.state.val + 1&#125;) console.log(this.state.val) // 3 &#125;, 0) &#125; render() &#123; return &lt;p&gt;&#123;this.state.val&#125;&lt;/p&gt; &#125;&#125; setState 默认异步更新1234567componentDidMount() &#123; this.setState(&#123;val: this.state.val + 1&#125;, () =&gt; &#123; // 回调函数可以拿到最新值 console.log(&#x27;callback&#x27;, this.state.val) &#125;) console.log(this.state.val) // 拿不到最新值&#125; setState 默认会合并多次执行，最后 render 结果还是 1 12345componentDidMount() &#123; this.setState(&#123;val: this.state.val + 1&#125;) this.setState(&#123;val: this.state.val + 1&#125;) this.setState(&#123;val: this.state.val + 1&#125;)&#125; setState 有时同步更新根据 setState 的触发时机是否受 React 控制 如果触发时机在 React 所控制的范围之内，则异步更新 生命周期内触发 React JSX 事件内触发 如果触发时机不在 React 所控制的范围之内，则同步更新 setTimeout setInterval 自定义的 DOM 事件 Promise then ajax 网络请求回调 setState 有时不会合并第一，同步更新，不会合并 第二，传入函数，不会合并 （对象可以 Object.assign，函数无法合并） 123this.setState((prevState, props) =&gt; &#123; return &#123; val: prevState.val + 1 &#125;&#125;) 答案题目代码执行打印 0 0 2 3 题目以下代码，运行会输出什么 123456let a = &#123; n: 1 &#125;let b = aa.x = a = &#123; n: 2 &#125;console.log(a.x) console.log(b.x) 值类型 vs 引用类型12345let a = 100let b = alet a = &#123; n: 1 &#125;let b = a 连续赋值连续赋值是倒序执行。PS：日常工作不可用连续赋值，可读性差 123456let n1, n2n1 = n2 = 100// // 相当于// n2 = 100// n1 = n2 . 优先级更高1234567let a = &#123;&#125;a.x = 100// 可拆解为：// 1. a.x = undefined // 初始化 a.x 属性// 2. a.x = 100 // 为 x 属性赋值 再看下面的例子 1234567let a = &#123; n: 1 &#125;a.x = a = &#123; n: 2 &#125;// // 可以拆解为// a.x = undefined// let x = a.x // x 变量是假想的，实际执行时不会有// x = a = &#123; n: 2 &#125; 答案题目代码执行打印 undefined 和 &#123; n: 2 &#125; 题目执行以下代码，会输出什么 1234567891011121314151617// example1let a = &#123;&#125;, b = &#x27;123&#x27;, c = 123a[b] = &#x27;b&#x27;a[c] = &#x27;c&#x27;console.log(a[b])// example 2let a = &#123;&#125;, b = Symbol(&#x27;123&#x27;), c = Symbol(&#x27;123&#x27;)a[b] = &#x27;b&#x27;a[c] = &#x27;c&#x27;console.log(a[b])// example 3let a = &#123;&#125;, b = &#123; key:&#x27;123&#x27; &#125;, c = &#123; key:&#x27;456&#x27; &#125;a[b] = &#x27;b&#x27;a[c] = &#x27;c&#x27;console.log(a[b]) 对象的 key 对象的键名只能是字符串和 Symbol 类型 其他类型的键名会被转换成字符串类型 对象转字符串默认会调用 toString 方法 12345678910const obj = &#123;&#125;obj[0] = 100const x = &#123; s: &#x27;abc&#x27; &#125;obj[x] = 200const y = Symbol()obj[y] = 300const z = trueobj[z] = 400Object.keys(obj) // [&#x27;0&#x27;, &#x27;[object Object]&#x27;, &#x27;true&#x27;] 有些类数组的结构是 &#123; 0: x, 1: y, 2: z, length: 3 &#125; ，如 document.getElementsByTagName(&#39;div&#39;)实际上它的 key 是 [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;length&#39;] 答案题目代码执行分别打印 &#39;c&#39; &#39;b&#39; &#39;c&#39;题目运行以下代码，会输出什么 123456789101112131415function changeArg(x) &#123; x = 200 &#125;let num = 100changeArg(num)console.log(&#x27;changeArg num&#x27;, num)let obj = &#123; name: &#x27;双越&#x27; &#125;changeArg(obj)console.log(&#x27;changeArg obj&#x27;, obj)function changeArgProp(x) &#123; x.name = &#x27;张三&#x27;&#125;changeArgProp(obj)console.log(&#x27;changeArgProp obj&#x27;, obj) 分析调用函数，传递参数 —— 赋值传递 123456function fn(x, y) &#123; // 继续操作 x y&#125;const num = 100const obj = &#123; name: &#x27;双越&#x27; &#125;fn(num, obj) 以上代码相当于 123456const num = 100const obj = &#123; name: &#x27;双越&#x27; &#125;let x = numlet y = obj// 继续操作 x y 解题执行题目代码分别输出 100 &#123;name: &#39;双越&#39;&#125; &#123;name: &#39;张三&#39;&#125;","categories":[],"tags":[]},{"title":"面试高频代码","slug":"面试高频代码","date":"2023-04-02T03:43:23.000Z","updated":"2023-04-07T05:43:44.667Z","comments":true,"path":"2023/04/02/面试高频代码/","link":"","permalink":"https://github.com/zheng521/2023/04/02/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E4%BB%A3%E7%A0%81/","excerpt":"","text":"遍历节点生成虚拟Dom 123456789101112131415161718192021222324252627282930313233class Vnode &#123; constructor(tag, data, value, type) &#123; this.tag = tag &amp;&amp; tag.toLowerCass() this.data = data this.value = value this.type = type this.children = [] &#125; appendChild(vnode) &#123; this.children.push(vnode) &#125;&#125;function createVnode(node) &#123; const nodeType = node.type let _vnode = null if (nodeType === 1) &#123; const tagName = node.nodeName const attrList = node.attributes const attrData = &#123;&#125; for (let i = 0; i &lt; attrList.length; i++) &#123; attrData[attrList[i].nodeName] = attrList[i].nodeName &#125; _vnode = new Vnode(tagName, attrData, null, 1) const childNodes = node.childNodes for (let i = 0; i &lt; childNodes.length; i++) &#123; _vnode.appendChild(createVnode(childNodes[i])) &#125; &#125; else if (nodeType === 3) &#123; _vnode = new Vnode(null, node.nodeValue, value, 3) &#125; return _vnode&#125; 通过虚拟dom生成真实节点 12345678910111213141516getRealNode(vnode) &#123; const &#123; tag, data, value, type, children &#125; = vnode let _node = null if (type === 1) &#123; _node = document.createElement(tag) for (let key in data) &#123; _node.setAttribute(key, data[key]) &#125; for (let i = 0; i &lt; children.length; i++) &#123; _node.appendChild(getRealNode(children[i])) &#125; &#125; else if (type === 3) &#123; _node = document.createTextNode(value) &#125; return _node&#125; 千分位格式话 123456789101112131415function format(n) &#123; let str = n.toString() let arr = str.split(&#x27;&#x27;).reverse() return arr.reduce((prev, cur, index) =&gt; &#123; if (index % 3 === 0) &#123; if (prev) &#123; return cur + &#x27;,&#x27; + prev &#125; else &#123; return cur &#125; &#125; else &#123; return cur + prev &#125; &#125;)&#125; Lazy man 1234567891011121314151617181920212223242526272829303132class LazyMan &#123; constructor (name) &#123; this.name = name this.tasks = [] setTimeout(() =&gt; &#123; this.next() &#125;) &#125; eat (foodName) &#123; const fn = () =&gt; &#123; console.log(`$&#123;this.name&#125; 吃了 $&#123;foodName&#125;`) this.next() &#125; this.tasks.push(fn) return this &#125; sleep (time) &#123; const fn = () &#123; setTimeout(() =&gt; &#123; console.log(`$&#123;this.name&#125; 睡了$&#123;time&#125;长时间`) this.next() &#125;, time * 1000) &#125; this.tasks.push(fn) return this &#125; next () &#123; let fn = this.tasks.length &amp;&amp; this.tasks.shift() fn() &#125;&#125; arrayToTree 数组构建树形结构数据 123456789101112131415161718192021222324/** * 数组转树形结构 * @param &#123;array&#125; list 被转换的数组 * @param &#123;number|string&#125; root 根节点（最外层节点） * @returns array */function arrayToTree(list, root) &#123; let map = &#123;&#125; for (let item of list) &#123; map[item.parentId] = item &#125; let result = [] for (let item of list) &#123; if (item.parentId === root) &#123; result.push(map[item.id]) &#125; else &#123; map[item.parentId].children = map[item.parentId].children ? map[item.parentId].push(map[item.id]) : (map[parent_id].children = [map[id]]) &#125; &#125; return result&#125; flattern 12345function myFlattern(arr) &#123; return arr.reduce((prev, cur) =&gt; prev.concat(Array.isArray(cur) ? myFlattern(cur): cur),[])&#125;","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/zheng521/tags/interview/"}]},{"title":"必会手写代码(js基础)","slug":"必会手写代码","date":"2023-04-01T04:33:14.000Z","updated":"2023-04-04T14:07:36.490Z","comments":true,"path":"2023/04/01/必会手写代码/","link":"","permalink":"https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/","excerpt":"","text":"new 实现 创建一个新对象 将新对象的原型属性指向构造函数的原型对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 (判断新对象是否为对象) &#96;&#96; function myNew(Func) &#123; let obj = &#123;&#125; obj._prop_ = Func.prototype let result = Func.apply(obj, arguments) return result instanceof Object ? result : obj &#125; instaceof 实现 function myInstaceOf(left, right) &#123; let prop = Object.getPrototypeOf(left) let prototype = right.prototype while (true) &#123; if (prop === null) return false if (prop === prototype) &#123; return true &#125; prop = Object.getPrototypeOf(prop) &#125; &#125; call 实现 function myCall(context) &#123; context = context || window context.fn = this let args = [...arguments].slice(1) let result = context.fn(...args) delete context.fn return result &#125; apply实现 function myApply(content) &#123; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; return result &#125; bind实现 function myBind(context) &#123; let self = this let args = [...arguments].slice(1) return function () &#123; let newArgs = [...arguments] return self.apply(context, args.concat(newArgs)) &#125; &#125; currry实现 function curry(fn, ...args) &#123; if (args.length &gt; fn.length) &#123; fn(...args) &#125; else &#123; return (..._args) =&gt; curry(fn, ...args, ..._args) &#125; &#125; compose实现 const compose = (...fns) =&gt; val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val); function compose (...fns) &#123; return val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val) &#125; pipe实现 const pipe = (...fns) =&gt; val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val); function compose (...fns) &#123; return val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val) &#125; throttle function throttle(fn, delay) &#123; let timer = null return function (...args) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, args) clearTimeout(timer) &#125;, delay) &#125; &#125; &#125; debounce function debounce(fn, time) &#123; let timer = null return function (...args) &#123; if (timer) clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, args) &#125;, time) &#125; &#125; object.Freeze 实现 function myFreeze(obj) &#123; if (obj instanceof Object) &#123; //封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置 Object.seal(obj) for (let p in obj) &#123; if (obj.hasOwnProperty(p)) &#123; Object.defineProperty(obj, p, &#123;writable: false&#125;) myFreeze(obj[p]) &#125; &#125; &#125; &#125; deepcopy function deepCopy(target, map = new WeakMap()) &#123; if (typeof(target) !== &#39;object&#39;) &#123; return &#125; if (map.get(target)) return map.get(target) let newObj = Array.isArray(target) ? [] : &#123;&#125; map.set(target, newObj) for (let key in target) &#123; if (targe.hasOwnProperty(key)) &#123; if (typeof(key) === &#39;object&#39;) &#123; newObj[key] = deepCopy(target[key]) &#125; else &#123; newObj[key] = target[key] &#125; &#125; &#125; return newObj &#125; reduce 实现 //语法 array.reduce(function(prev, currentValue, currentIndex, arr), initialValue) function myReduce(func, initVal) &#123; let arr = this let base = initVal ? initVal : arr[0] let startPoint = initVal ? 1 : 0 arr.slice(startPoint).forEach((val, index) =&gt; &#123; let base = func(base, val, index+startPoint, arr) &#125;) return base &#125; map 实现 function myMap(fn, thisArg = []) &#123; return this.reduce((prev, cur, index, arr) =&gt; &#123; return prev.concat(fn.call(thisArg, cur, index, arr)) &#125;, []) &#125; Promise 实现 const PENDING = &#39;pending&#39; const FULFILLED = &#39;fulfilled&#39; const REJECT = &#39;reject&#39; class Promise &#123; constructor () &#123; this.staus = PENDING this.value = &#39;&#39; this.reason = &#39;&#39; this.onResolvedCallBack = [] this.onRejectedCallBack = [] let resolve = (value) =&gt; &#123; if (this.status === PENDING) &#123; this.status = FULFILLED this.value = value this.onResolvedCallBack.forEach(fn =&gt; fn()) &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === PENDING) &#123; this.status = REJECT this.reason = reason this.onRejectedCallBack.forEach(fn =&gt; fn()) &#125; &#125; try &#123; exector(resolve, reject) &#125; catch(err) &#123; reject(err) &#125; &#125; then(onFulfilled, onRejected) &#123; if (this.status === FULFIllED) &#123; onFulfilled(this.value) &#125; if (this.status === REJECT) &#123; onRejected(this.reason) &#125; if (this.status === PENDING) &#123; this.onResolvedCallBack.push(() =&gt; onFulfilled(this.value)) this.onRejectedCallBack.push(() =&gt; onRejected(this.reason)) &#125; &#125; &#125; promiseAll function promiseAll(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = [] let count = 0 promises.forEach((promise, index) =&gt; &#123; promise.then(res =&gt; &#123; result.push(res) count++ if (count === promises.length) &#123; resolve(result) &#125; &#125;, err =&gt; reject(err)) &#125;) &#125;) &#125; promiseFinally function promiseFinally(cb) &#123; return this.then(value =&gt; &#123; return Promise.resolve(cb()).then(() =&gt; value) &#125;, err =&gt; &#123; return Promise.resolve(cb()).then(() =&gt; err) &#125;) &#125; promiseAllSetted function promiseAllSetted(promises) &#123; _promises = promises.map(item =&gt; item instanceof Promise ? item : Promise.resolve(item)) return new Promise((resolve, reject) =&gt; &#123; let result = [] let unSettedCount = _promise.length _promises.forEach((promise, index) =&gt; &#123; promise.then(res =&gt; &#123; result[index] = &#123; status: &#39;fulfilled&#39;, res &#125; unSettedCount-- unSettedCount === 0 &amp;&amp; resolve(result) &#125;, err =&gt; &#123; result[index] = &#123; status: &#39;reject&#39;, err &#125; unSettedCount-- unSettedCount === 0 &amp;&amp; reject(result) &#125;) &#125;) &#125;) &#125; promiseRace function promiseRace(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; promise.then(res =&gt; resolve(res), err =&gt; reject(err)) &#125;) &#125;) &#125; promiseAny function promiseAny(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let count = 0 promises.forEach(promise =&gt; &#123; promise.then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; count++ count === promises.length &amp;&amp; reject(err) &#125;) &#125;) &#125;) &#125; async&#x2F;await 自动执行器 function runGenerator(gen) &#123; return new Promise((resolve, reject) =&gt; &#123; let g = gen() function _next() &#123; let res try &#123; res = g.next(val) &#125; catch(err) &#123; return reject(err) &#125; if (res.done) &#123; return resolve(res.value) &#125; //res.value包装为promise，以兼容yield后面跟基本类型的情况 Promise.resolve(res.value).then(val =&gt; &#123; _next(val) &#125;, err =&gt; &#123; g.throw(err) &#125;) &#125; _next() &#125;) &#125; JSON.stringify 实现 function jsonStringify(data) &#123; let type = typeof data; if(type !== &#39;object&#39;) &#123; let result = data; //data 可能是基础数据类型的情况在这里处理 if (Number.isNaN(data) || data === Infinity) &#123; //NaN 和 Infinity 序列化返回 &quot;null&quot; result = &quot;null&quot;; &#125; else if (type === &#39;function&#39; || type === &#39;undefined&#39; || type === &#39;symbol&#39;) &#123; // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理 return undefined; &#125; else if (type === &#39;string&#39;) &#123; result = &#39;&quot;&#39; + data + &#39;&quot;&#39;; &#125; return String(result); &#125; else if (type === &#39;object&#39;) &#123; if (data === null) &#123; return &quot;null&quot; // 第01讲有讲过 typeof null 为&#39;object&#39;的特殊情况 &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &#39;function&#39;) &#123; return jsonStringify(data.toJSON()); &#125; else if (data instanceof Array) &#123; let result = []; //如果是数组，那么数组里面的每一项类型又有可能是多样的 data.forEach((item, index) =&gt; &#123; if (typeof item === &#39;undefined&#39; || typeof item === &#39;function&#39; || typeof item === &#39;symbol&#39;) &#123; result[index] = &quot;null&quot;; &#125; else &#123; result[index] = jsonStringify(item); &#125; &#125;); result = &quot;[&quot; + result + &quot;]&quot;; return result.replace(/&#39;/g, &#39;&quot;&#39;); &#125; else &#123; // 处理普通对象 let result = []; Object.keys(data).forEach((item, index) =&gt; &#123; if (typeof item !== &#39;symbol&#39;) &#123; //key 如果是 symbol 对象，忽略 if (data[item] !== undefined &amp;&amp; typeof data[item] !== &#39;function&#39; &amp;&amp; typeof data[item] !== &#39;symbol&#39;) &#123; //键值如果是 undefined、function、symbol 为属性值，忽略 result.push(&#39;&quot;&#39; + item + &#39;&quot;&#39; + &quot;:&quot; + jsonStringify(data[item])); &#125; &#125; &#125;); return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&#39;/g, &#39;&quot;&#39;); &#125; &#125; &#125; JSON.parse 实现 var json = &#39;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#39;; // obj 就是 json 反序列化之后得到的对象 var obj = eval(&quot;(&quot; + json + &quot;)&quot;);","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/zheng521/tags/interview/"}]}],"categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/zheng521/tags/interview/"}]}