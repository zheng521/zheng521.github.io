{"meta":{"title":"初见","subtitle":null,"description":null,"author":"zheng","url":"https://github.com/zheng521","root":"/"},"pages":[],"posts":[{"title":"前端基础","slug":"前端基础","date":"2023-04-04T14:14:21.000Z","updated":"2023-04-04T14:18:17.358Z","comments":true,"path":"2023/04/04/前端基础/","link":"","permalink":"https://github.com/zheng521/2023/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/","excerpt":"","text":"箭头函数的缺点题目什么时候不能使用箭头函数？ 箭头函数的缺点没有 arguments 1234const fn1 = () =&gt; &#123; console.log(&#x27;this&#x27;, arguments) // 报错，arguments is not defined&#125;fn1(100, 200) 无法通过 call apply bind 等改变 this 1234const fn1 = () =&gt; &#123; console.log(&#x27;this&#x27;, this) // window&#125;fn1.call(&#123; x: 100 &#125;) 简写的函数会变得难以阅读 1const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b 不适用箭头函数的场景对象方法 1234567const obj = &#123; name: &#x27;张三&#x27;, getName: () =&gt; &#123; return this.name &#125;&#125;console.log( obj.getName() ) 扩展对象原型（包括构造函数的原型） 1234567const obj = &#123; name: &#x27;张三&#x27;&#125;obj.__proto__.getName = () =&gt; &#123; return this.name&#125;console.log( obj.getName() ) 构造函数 12345const Foo = (name, age) =&gt; &#123; this.name = name this.age = age&#125;const f = new Foo(&#x27;张三&#x27;, 20) // 报错 Foo is not a constructor 动态上下文中的回调函数 12345const btn1 = document.getElementById(&#x27;btn1&#x27;)btn1.addEventListener(&#x27;click&#x27;, () =&gt; &#123; // console.log(this === window) this.innerHTML = &#x27;clicked&#x27;&#125;) Vue 生命周期和方法 12345678910111213141516171819&#123; data() &#123; return &#123; name: &#x27;张三&#x27; &#125; &#125;, methods: &#123; getName: () =&gt; &#123; // 报错 Cannot read properties of undefined (reading &#x27;name&#x27;) return this.name &#125;, // getName() &#123; // return this.name // 正常 // &#125; &#125;, mounted: () =&gt; &#123; // 报错 Cannot read properties of undefined (reading &#x27;name&#x27;) console.log(&#x27;msg&#x27;, this.name) &#125;, // mounted() &#123; // console.log(&#x27;msg&#x27;, this.name) // 正常 // &#125;&#125; 【注意】class 中使用箭头函数则没问题 1234567891011class Foo &#123; constructor(name, age) &#123; this.name = name this.age = age &#125; getName = () =&gt; &#123; return this.name &#125;&#125;const f = new Foo(&#x27;张三&#x27;, 20)console.log(&#x27;getName&#x27;, f.getName()) 所以，在 React 中可以使用箭头函数 1234567891011121314export default class HelloWorld extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; name: &#x27;张三&#x27; &#125; &#125; render() &#123; return &lt;p onClick=&#123;this.printName&#125;&gt;hello world&lt;/p&gt; &#125; printName = () =&gt; &#123; console.log(this.state.name) &#125;&#125; 答案箭头函数的缺点 arguments 参数 无法改变 this 不适用的场景 对象方法 对象原型 构造函数 动态上下文 Vue 生命周期和方法 for…in 和 for…of 的区别题目for…in 和 for…of 的区别 key 和 valuefor…in 遍历 key , for…of 遍历 value 123456789const arr = [10, 20, 30]for (let n of arr) &#123; console.log(n)&#125;const str = &#x27;abc&#x27;for (let s of str) &#123; console.log(s)&#125; 1234567891011function fn() &#123; for (let argument of arguments) &#123; console.log(argument) // for...of 可以获取 value ，而 for...in 获取 key &#125;&#125;fn(10, 20, 30)const pList = document.querySelectorAll(&#x27;p&#x27;)for (let p of pList) &#123; console.log(p) // for...of 可以获取 value ，而 for...in 获取 key&#125; 遍历对象for…in 可以遍历对象，for…of 不可以 遍历 Map&#x2F;Setfor…of 可以遍历 Map&#x2F;Set ，for…in 不可以 1234567891011const set1 = new Set([10, 20, 30])for (let n of set1) &#123; console.log(n)&#125;let map1 = new Map([ [&#x27;x&#x27;, 10], [&#x27;y&#x27;, 20], [&#x27;z&#x27;, 3]])for (let n of map1) &#123; console.log(n)&#125; 遍历 generatorfor…of 可遍历 generator ，for…in 不可以 12345678function* foo()&#123; yield 10 yield 20 yield 30&#125;for (let o of foo()) &#123; console.log(o)&#125; 对象的可枚举属性for…in 遍历一个对象的可枚举属性。 使用 Object.getOwnPropertyDescriptors(obj) 可以获取对象的所有属性描述，看 enumerable: true 来判断该属性是否可枚举。 对象，数组，字符传 可迭代对象for…of 遍历一个可迭代对象。其实就是迭代器模式，通过一个 next 方法返回下一个元素。 该对象要实现一个 [Symbol.iterator] 方法，其中返回一个 next 函数，用于返回下一个 value（不是 key）。可以执行 arr[Symbol.iterator]() 看一下。 JS 中内置迭代器的类型有 String Array arguments NodeList Map Set generator 等。 答案 for…in 遍历一个对象的可枚举属性，如对象、数组、字符串。针对属性，所以获得 key for…of 遍历一个可迭代对象，如数组、字符串、Map&#x2F;Set 。针对一个迭代对象，所以获得 value 划重点“枚举” “迭代” 都是计算机语言的一些基础术语，目前搞不懂也没关系。但请一定记住 for…of 和 for…in 的不同表现。 连环问：for await…of用于遍历异步请求的可迭代对象。 12345678// 像定义一个创建 promise 的函数function createTimeoutPromise(val) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(val) &#125;, 1000) &#125;)&#125; 如果你明确知道有几个 promise 对象，那直接处理即可 123456789(async function () &#123; const p1 = createTimeoutPromise(10) const p2 = createTimeoutPromise(20) const v1 = await p1 console.log(v1) const v2 = await p2 console.log(v2)&#125;)() 如果你有一个对象，里面有 N 个 promise 对象，你可以这样处理 12345678910111213141516(async function () &#123; const list = [ createTimeoutPromise(10), createTimeoutPromise(20) ] // 第一，使用 Promise.all 执行 Promise.all(list).then(res =&gt; console.log(res)) // 第二，使用 for await ... of 遍历执行 for await (let p of list) &#123; console.log(p) &#125; // 注意，如果用 for...of 只能遍历出各个 promise 对象，而不能触发 await 执行&#125;)() 【注意】如果你想顺序执行，只能延迟创建 promise 对象，而不能及早创建。即，你创建了 promise 对象，它就立刻开始执行逻辑。 1234567891011(async function () &#123; const v1 = await createTimeoutPromise(10) console.log(v1) const v2 = await createTimeoutPromise(20) console.log(v2) for (let n of [100, 200]) &#123; const v = await createTimeoutPromise(n) console.log(&#x27;v&#x27;, v) &#125;&#125;)() HTMLCollection 和 NodeList 的区别题目HTMLCollection 和 NodeList 的区别，Node 和 Element 的区别 Node 和 ElementDOM 结构是一棵树，树的所有节点都是 Node ，包括：document，元素，文本，注释，fragment 等 Element 继承于 Node 。它是所有 html 元素的基类，如 HTMLParagraphElement HTMLDivElement 1234567891011121314151617class Node &#123;&#125;// documentclass Document extends Node &#123;&#125;class DocumentFragment extends Node &#123;&#125;// 文本和注释class CharacterData extends Node &#123;&#125;class Comment extends CharacterData &#123;&#125;class Text extends CharacterData &#123;&#125;// elemclass Element extends Node &#123;&#125;class HTMLElement extends Element &#123;&#125;class HTMLParagraphElement extends HTMLElement &#123;&#125;class HTMLDivElement extends HTMLElement &#123;&#125;// ... 其他 elem ... HTMLCollection 和 NodeListHTMLCollection 是 Element 集合，它由获取 Element 的 API 返回 elem.children document.getElementsByTagName(&#39;p&#39;) NodeList 是 Node 集合，它由获取 Node 的 API 返回 document.querySelectorAll(&#39;p&#39;) elem.childNodes 答案 HTMLCollection 是 Element 集合，NodeList 是 Node 集合 Node 是所有 DOM 节点的基类，Element 是 html 元素的基类 划重点注意 Node 和 Element 在实际 API 中的区别，如 children 和 childNodes 获取的结果可能是不一样的（如果子节点有 Text 或 Comment） 扩展：类数组HTMLCollection 和 NodeList 都不是数组，而是“类数组”。转换为数组： 1234// HTMLCollection 和 NodeList 都不是数组，而是“类数组”const arr1 = Array.from(list)const arr2 = Array.prototype.slice.call(list)const arr3 = [...list] JS 严格模式和非严格模式题目JS 严格模式和非严格模式的区别 设计初衷Javascript 设计之初，有很多不合理、不严谨、不安全之处，例如变量未定义即可使用 n = 100。严格模式用于规避这些问题。 而现在 ES 规范已经普及，从语法上已经规避了这些问题。 开启严格模式代码（或一个函数）一开始插入一行 &#39;use strict&#39; 即可开启严格模式 123456&#x27;use strict&#x27; // 全局开启function fn() &#123; &#x27;use strict&#x27; // 某个函数开启&#125; 一般情况下，开发环境用 ES 或者 Typescript ，打包出的 js 代码使用严格模式 严格模式的不同严格模式的细则有很多，这里总结一些常用常见的 全局变量必须声明12&#x27;use strict&#x27;n = 10 // ReferenceError: n is not defined 禁止使用 with123456&#x27;use strict&#x27;var obj = &#123; x: 10 &#125;with (obj) &#123; // Uncaught SyntaxError: Strict mode code may not include a with statement console.log(x)&#125; 创建 eval 作用域正常模式下，JS 只有两种变量作用域：全局作用域 + 函数作用域。严格模式下，JS 增加了 eval 作用域。 chrome 隐私模式下执行这段代码？？？ 1234&#x27;use strict&#x27;var x = 10eval(&#x27;var x = 20; console.log(x)&#x27;)console.log(x) 禁止 this 指向全局作用域12345&#x27;use strict&#x27;function fn() &#123; console.log(&#x27;this&#x27;, this) // undefined&#125;fn() 函数参数不能重名123456&#x27;use strict&#x27;// Uncaught SyntaxError: Duplicate parameter name not allowed in this contextfunction fn(x, x, y) &#123; return&#125; 答案 全局变量必须声明 禁止使用 with 创建 eval 作用域 禁止 this 指向全局作用域 函数参数不能重名 options 请求题目跨域为何需要 options 请求？ 跨域浏览器同源策略，默认限制跨域请求。跨域的解决方案 jsonp CORS 12345// CORS 配置允许跨域（服务端）response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://localhost:8011&quot;) // 或者 &#x27;*&#x27;response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;X-Requested-With&quot;)response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;PUT,POST,GET,DELETE,OPTIONS&quot;)response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;) // 允许跨域接收 cookie options 请求使用 CORS 跨域请求时，经常会看到一个“多余”的 options 请求，之后才发送了实际的请求。 该请求就是为了检查服务端的 headers 信息，是否符合客户端的预期。所以它没有 body 的返回。 规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。—— MDN 答案options 请求就是对 CORS 跨域请求之间的一次预检查，检查成功再发起正式请求，是浏览器自行处理的。了解即可，实际开发中不用过于关注。","categories":[],"tags":[]},{"title":"输出什么","slug":"输出什么","date":"2023-04-04T13:49:17.000Z","updated":"2023-04-04T14:09:57.469Z","comments":true,"path":"2023/04/04/输出什么/","link":"","permalink":"https://github.com/zheng521/2023/04/04/%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/","excerpt":"","text":"题目[1,2,3].map(parseInt)输出什么 解析parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数 string 要解析的字符串 radix 可选参数，数字基数（即进制），范围为 2-36 示例 1234567891011parseInt(&#x27;11&#x27;, 1) // NaN ，1 非法，不在 2-36 范围之内parseInt(&#x27;11&#x27;, 2) // 3 = 1*2 + 1parseInt(&#x27;3&#x27;, 2) // NaN ，2 进制中不存在 3parseInt(&#x27;11&#x27;, 3) // 4 = 1*3 + 1parseInt(&#x27;11&#x27;, 8) // 9 = 1*8 + 1parseInt(&#x27;9&#x27;, 8) // NaN ，8 进制中不存在 9parseInt(&#x27;11&#x27;, 10) // 11parseInt(&#x27;A&#x27;, 16) // 10 ，超过 10 进制，个位数就是 1 2 3 4 5 6 7 8 9 A B C D ...parseInt(&#x27;F&#x27;, 16) // 15parseInt(&#x27;G&#x27;, 16) // NaN ，16 进制个位数最多是 F ，不存在 GparseInt(&#x27;1F&#x27;, 16) // 31 = 1*16 + F radix &#x3D;&#x3D; null 或者 radix &#x3D;&#x3D;&#x3D; 0 如果 string 以 0x 开头，则按照 16 进制处理，例如 parseInt(&#39;0x1F&#39;) 等同于 parseInt(&#39;1F&#39;, 16) 如果 string 以 0 开头，则按照 8 进制处理 —— ES5 之后就取消了，改为按 10 进制处理，但不是所有浏览器都这样，一定注意！！！ 其他情况，按 10 进制处理 分析代码题目代码可以拆解为 123456const arr = [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;]const res = arr.map((s, index) =&gt; &#123; console.log(`s is $&#123;s&#125;, index is $&#123;index&#125;`) return parseInt(s, index)&#125;)console.log(res) 分析执行过程 123parseInt(&#x27;1&#x27;, 0) // 1 ，radix === 0 按 10 进制处理parseInt(&#x27;2&#x27;, 1) // NaN ，radix === 1 非法（不在 2-36 之内）parseInt(&#x27;3&#x27;, 2) // NaN ，2 进制中没有 3 题目以下代码，执行会输出什么？ 1234567891011function Foo() &#123; Foo.a = function() &#123; console.log(1) &#125; this.a = function() &#123; console.log(2) &#125;&#125;Foo.prototype.a = function() &#123; console.log(3) &#125;Foo.a = function() &#123; console.log(4) &#125;Foo.a()let obj = new Foo()obj.a()Foo.a() 解析：执行完new以后,函数执行内部函数体会覆盖原来的函数 答案： 4 2 1 题目以下代码，执行会输出什么？ 123456789101112131415161718Promise.resolve().then(() =&gt; &#123; console.log(0) return Promise.resolve(4)&#125;).then((res) =&gt; &#123; console.log(res)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(1)&#125;).then(() =&gt; &#123; console.log(2)&#125;).then(() =&gt; &#123; console.log(3)&#125;).then(() =&gt; &#123; console.log(5)&#125;).then(() =&gt;&#123; console.log(6)&#125;) 解析：then 交替执行如果有多个 fulfilled 状态的 promise 实例，同时执行 then 链式调用，then 会交替调用这是编译器的优化，防止一个 promise 持续占据事件 1234567891011121314151617181920212223242526272829Promise.resolve().then(() =&gt; &#123; console.log(1)&#125;).then(() =&gt; &#123; console.log(2)&#125;).then(() =&gt; &#123; console.log(3)&#125;).then(() =&gt; &#123; console.log(4)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(10)&#125;).then(() =&gt; &#123; console.log(20)&#125;).then(() =&gt; &#123; console.log(30)&#125;).then(() =&gt; &#123; console.log(40)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(100)&#125;).then(() =&gt; &#123; console.log(200)&#125;).then(() =&gt; &#123; console.log(300)&#125;).then(() =&gt; &#123; console.log(400)&#125;) then 返回 promise 对象当 then 返回 promise 对象时，可以认为是多出一个 promise 实例。 123456789101112131415161718192021222324252627282930313233Promise.resolve().then(() =&gt; &#123; console.log(1) return Promise.resolve(100) // 相当于多处一个 promise 实例，如下注释的代码&#125;).then(res =&gt; &#123; console.log(res)&#125;).then(() =&gt; &#123; console.log(200)&#125;).then(() =&gt; &#123; console.log(300)&#125;).then(() =&gt; &#123; console.log(300)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(10)&#125;).then(() =&gt; &#123; console.log(20)&#125;).then(() =&gt; &#123; console.log(30)&#125;).then(() =&gt; &#123; console.log(40)&#125;)// // 相当于新增一个 promise 实例 —— 但这个执行结果不一样，后面解释// Promise.resolve(100).then(res =&gt; &#123;// console.log(res)// &#125;).then(() =&gt; &#123;// console.log(200)// &#125;).then(() =&gt; &#123;// console.log(300)// &#125;).then(() =&gt; &#123;// console.log(400)// &#125;) “慢两拍”then 返回 promise 实例和直接执行 Promise.resolve() 不一样，它需要等待两个过程 promise 状态由 pending 变为 fulfilled then 函数挂载到 microTaskQueue 所以，它变现的会“慢两拍”。可以理解为 123456789101112131415161718192021222324252627282930Promise.resolve().then(() =&gt; &#123; console.log(1)&#125;)Promise.resolve().then(() =&gt; &#123; console.log(10)&#125;).then(() =&gt; &#123; console.log(20)&#125;).then(() =&gt; &#123; console.log(30)&#125;).then(() =&gt; &#123; console.log(40)&#125;)Promise.resolve().then(() =&gt; &#123; // 第一拍 const p = Promise.resolve(100) Promise.resolve().then(() =&gt; &#123; // 第二拍 p.then(res =&gt; &#123; console.log(res) &#125;).then(() =&gt; &#123; console.log(200) &#125;).then(() =&gt; &#123; console.log(300) &#125;).then(() =&gt; &#123; console.log(400) &#125;) &#125;)&#125;) 答案题目代码输出的结果是 1 2 3 4 5 6 题目React 中以下代码会输出什么 12345678910111213141516171819202122232425262728class Example extends React.Component &#123; constructor() &#123; super() this.state = &#123; val: 0 &#125; &#125; componentDidMount() &#123; // this.state.val 初始值是 0 this.setState(&#123;val: this.state.val + 1&#125;) console.log(this.state.val) //0 this.setState(&#123;val: this.state.val + 1&#125;) console.log(this.state.val) //0 setTimeout(() =&gt; &#123; this.setState(&#123;val: this.state.val + 1&#125;) console.log(this.state.val) // 2 this.setState(&#123;val: this.state.val + 1&#125;) console.log(this.state.val) // 3 &#125;, 0) &#125; render() &#123; return &lt;p&gt;&#123;this.state.val&#125;&lt;/p&gt; &#125;&#125; setState 默认异步更新1234567componentDidMount() &#123; this.setState(&#123;val: this.state.val + 1&#125;, () =&gt; &#123; // 回调函数可以拿到最新值 console.log(&#x27;callback&#x27;, this.state.val) &#125;) console.log(this.state.val) // 拿不到最新值&#125; setState 默认会合并多次执行，最后 render 结果还是 1 12345componentDidMount() &#123; this.setState(&#123;val: this.state.val + 1&#125;) this.setState(&#123;val: this.state.val + 1&#125;) this.setState(&#123;val: this.state.val + 1&#125;)&#125; setState 有时同步更新根据 setState 的触发时机是否受 React 控制 如果触发时机在 React 所控制的范围之内，则异步更新 生命周期内触发 React JSX 事件内触发 如果触发时机不在 React 所控制的范围之内，则同步更新 setTimeout setInterval 自定义的 DOM 事件 Promise then ajax 网络请求回调 setState 有时不会合并第一，同步更新，不会合并 第二，传入函数，不会合并 （对象可以 Object.assign，函数无法合并） 123this.setState((prevState, props) =&gt; &#123; return &#123; val: prevState.val + 1 &#125;&#125;) 答案题目代码执行打印 0 0 2 3 题目以下代码，运行会输出什么 123456let a = &#123; n: 1 &#125;let b = aa.x = a = &#123; n: 2 &#125;console.log(a.x) console.log(b.x) 值类型 vs 引用类型12345let a = 100let b = alet a = &#123; n: 1 &#125;let b = a 连续赋值连续赋值是倒序执行。PS：日常工作不可用连续赋值，可读性差 123456let n1, n2n1 = n2 = 100// // 相当于// n2 = 100// n1 = n2 . 优先级更高1234567let a = &#123;&#125;a.x = 100// 可拆解为：// 1. a.x = undefined // 初始化 a.x 属性// 2. a.x = 100 // 为 x 属性赋值 再看下面的例子 1234567let a = &#123; n: 1 &#125;a.x = a = &#123; n: 2 &#125;// // 可以拆解为// a.x = undefined// let x = a.x // x 变量是假想的，实际执行时不会有// x = a = &#123; n: 2 &#125; 答案题目代码执行打印 undefined 和 &#123; n: 2 &#125; 题目执行以下代码，会输出什么 1234567891011121314151617// example1let a = &#123;&#125;, b = &#x27;123&#x27;, c = 123a[b] = &#x27;b&#x27;a[c] = &#x27;c&#x27;console.log(a[b])// example 2let a = &#123;&#125;, b = Symbol(&#x27;123&#x27;), c = Symbol(&#x27;123&#x27;)a[b] = &#x27;b&#x27;a[c] = &#x27;c&#x27;console.log(a[b])// example 3let a = &#123;&#125;, b = &#123; key:&#x27;123&#x27; &#125;, c = &#123; key:&#x27;456&#x27; &#125;a[b] = &#x27;b&#x27;a[c] = &#x27;c&#x27;console.log(a[b]) 对象的 key 对象的键名只能是字符串和 Symbol 类型 其他类型的键名会被转换成字符串类型 对象转字符串默认会调用 toString 方法 12345678910const obj = &#123;&#125;obj[0] = 100const x = &#123; s: &#x27;abc&#x27; &#125;obj[x] = 200const y = Symbol()obj[y] = 300const z = trueobj[z] = 400Object.keys(obj) // [&#x27;0&#x27;, &#x27;[object Object]&#x27;, &#x27;true&#x27;] 有些类数组的结构是 &#123; 0: x, 1: y, 2: z, length: 3 &#125; ，如 document.getElementsByTagName(&#39;div&#39;)实际上它的 key 是 [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;length&#39;] 答案题目代码执行分别打印 &#39;c&#39; &#39;b&#39; &#39;c&#39;题目运行以下代码，会输出什么 123456789101112131415function changeArg(x) &#123; x = 200 &#125;let num = 100changeArg(num)console.log(&#x27;changeArg num&#x27;, num)let obj = &#123; name: &#x27;双越&#x27; &#125;changeArg(obj)console.log(&#x27;changeArg obj&#x27;, obj)function changeArgProp(x) &#123; x.name = &#x27;张三&#x27;&#125;changeArgProp(obj)console.log(&#x27;changeArgProp obj&#x27;, obj) 分析调用函数，传递参数 —— 赋值传递 123456function fn(x, y) &#123; // 继续操作 x y&#125;const num = 100const obj = &#123; name: &#x27;双越&#x27; &#125;fn(num, obj) 以上代码相当于 123456const num = 100const obj = &#123; name: &#x27;双越&#x27; &#125;let x = numlet y = obj// 继续操作 x y 解题执行题目代码分别输出 100 &#123;name: &#39;双越&#39;&#125; &#123;name: &#39;张三&#39;&#125;","categories":[],"tags":[]},{"title":"面试高频代码","slug":"面试高频代码","date":"2023-04-02T03:43:23.000Z","updated":"2023-04-04T13:40:49.523Z","comments":true,"path":"2023/04/02/面试高频代码/","link":"","permalink":"https://github.com/zheng521/2023/04/02/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E4%BB%A3%E7%A0%81/","excerpt":"","text":"遍历节点生成虚拟Dom 123456789101112131415161718192021222324252627282930313233class Vnode &#123; constructor(tag, data, value, type) &#123; this.tag = tag &amp;&amp; tag.toLowerCass() this.data = data this.value = value this.type = type this.children = [] &#125; appendChild(vnode) &#123; this.children.push(vnode) &#125;&#125;function createVnode(node) &#123; const nodeType = node.type let _vnode = null if (nodeType === 1) &#123; const tagName = node.nodeName const attrList = node.attributes const attrData = &#123;&#125; for (let i = 0; i &lt; attrList.length; i++) &#123; attrData[attrList[i].nodeName] = attrList[i].nodeName &#125; _vnode = new Vnode(tagName, attrData, null, 1) const childNodes = node.childNodes for (let i = 0; i &lt; childNodes.length; i++) &#123; _vnode.appendChild(createVnode(childNodes[i])) &#125; &#125; else if (nodeType === 3) &#123; _vnode = new Vnode(null, node.nodeValue, value, 3) &#125; return _vnode&#125; 通过虚拟dom生成真实节点 12345678910111213141516getRealNode(vnode) &#123; const &#123; tag, data, value, type, children &#125; = vnode let _node = null if (type === 1) &#123; _node = document.createElement(tag) for (let key in data) &#123; _node.setAttribute(key, data[key]) &#125; for (let i = 0; i &lt; children.length; i++) &#123; _node.appendChild(getRealNode(children[i])) &#125; &#125; else if (type === 3) &#123; _node = document.createTextNode(value) &#125; return _node&#125; 千分位格式话 123456789101112131415function format(n) &#123; let str = n.toString() let arr = str.split(&#x27;&#x27;).reverse() return arr.reduce((prev, cur, index) =&gt; &#123; if (index % 3 === 0) &#123; if (prev) &#123; return cur + &#x27;,&#x27; + prev &#125; else &#123; return cur &#125; &#125; else &#123; return cur + prev &#125; &#125;)&#125; Lazy man 1234567891011121314151617181920212223242526272829class LazyMan &#123; constructor (name) &#123; this.name = name this.tasks = [] &#125; eat (foodName) &#123; const fn = () =&gt; &#123; console.log(`$&#123;this.name&#125; 吃了 $&#123;foodName&#125;`) this.next() &#125; this.tasks.push(fn) return this &#125; sleep (time) &#123; const fn = () &#123; setTimeout(() =&gt; &#123; console.log(`$&#123;this.name&#125; 睡了$&#123;time&#125;长时间`) this.next() &#125;, time * 1000) &#125; this.tasks.push(fn) return this &#125; next () &#123; let fn = this.tasks.length &amp;&amp; this.tasks.shift() fn() &#125;&#125; arrayToTree 数组构建树形结构数据 123456789101112131415161718192021222324/** * 数组转树形结构 * @param &#123;array&#125; list 被转换的数组 * @param &#123;number|string&#125; root 根节点（最外层节点） * @returns array */function arrayToTree(list, root) &#123; let map = &#123;&#125; for (let item of list) &#123; map[item.parentId] = item &#125; let result = [] for (let item of list) &#123; if (item.parentId === root) &#123; result.push(map[item.id]) &#125; else &#123; map[item.parentId].children = map[item.parentId].children ? map[item.parentId].push(map[item.id]) : (map[parent_id].children = [map[id]]) &#125; &#125; return result&#125; flattern 12345function myFlattern(arr) &#123; return arr.reduce((prev, cur) =&gt; prev.concat(Array.isArray(cur) ? myFlattern(cur): cur),[])&#125;","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/zheng521/tags/interview/"}]},{"title":"必会手写代码(js基础)","slug":"必会手写代码","date":"2023-04-01T04:33:14.000Z","updated":"2023-04-04T14:07:36.490Z","comments":true,"path":"2023/04/01/必会手写代码/","link":"","permalink":"https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/","excerpt":"","text":"new 实现 创建一个新对象 将新对象的原型属性指向构造函数的原型对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 (判断新对象是否为对象) &#96;&#96; function myNew(Func) &#123; let obj = &#123;&#125; obj._prop_ = Func.prototype let result = Func.apply(obj, arguments) return result instanceof Object ? result : obj &#125; instaceof 实现 function myInstaceOf(left, right) &#123; let prop = Object.getPrototypeOf(left) let prototype = right.prototype while (true) &#123; if (prop === null) return false if (prop === prototype) &#123; return true &#125; prop = Object.getPrototypeOf(prop) &#125; &#125; call 实现 function myCall(context) &#123; context = context || window context.fn = this let args = [...arguments].slice(1) let result = context.fn(...args) delete context.fn return result &#125; apply实现 function myApply(content) &#123; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; return result &#125; bind实现 function myBind(context) &#123; let self = this let args = [...arguments].slice(1) return function () &#123; let newArgs = [...arguments] return self.apply(context, args.concat(newArgs)) &#125; &#125; currry实现 function curry(fn, ...args) &#123; if (args.length &gt; fn.length) &#123; fn(...args) &#125; else &#123; return (..._args) =&gt; curry(fn, ...args, ..._args) &#125; &#125; compose实现 const compose = (...fns) =&gt; val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val); function compose (...fns) &#123; return val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val) &#125; pipe实现 const pipe = (...fns) =&gt; val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val); function compose (...fns) &#123; return val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val) &#125; throttle function throttle(fn, delay) &#123; let timer = null return function (...args) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, args) clearTimeout(timer) &#125;, delay) &#125; &#125; &#125; debounce function debounce(fn, time) &#123; let timer = null return function (...args) &#123; if (timer) clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, args) &#125;, time) &#125; &#125; object.Freeze 实现 function myFreeze(obj) &#123; if (obj instanceof Object) &#123; //封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置 Object.seal(obj) for (let p in obj) &#123; if (obj.hasOwnProperty(p)) &#123; Object.defineProperty(obj, p, &#123;writable: false&#125;) myFreeze(obj[p]) &#125; &#125; &#125; &#125; deepcopy function deepCopy(target, map = new WeakMap()) &#123; if (typeof(target) !== &#39;object&#39;) &#123; return &#125; if (map.get(target)) return map.get(target) let newObj = Array.isArray(target) ? [] : &#123;&#125; map.set(target, newObj) for (let key in target) &#123; if (targe.hasOwnProperty(key)) &#123; if (typeof(key) === &#39;object&#39;) &#123; newObj[key] = deepCopy(target[key]) &#125; else &#123; newObj[key] = target[key] &#125; &#125; &#125; return newObj &#125; reduce 实现 //语法 array.reduce(function(prev, currentValue, currentIndex, arr), initialValue) function myReduce(func, initVal) &#123; let arr = this let base = initVal ? initVal : arr[0] let startPoint = initVal ? 1 : 0 arr.slice(startPoint).forEach((val, index) =&gt; &#123; let base = func(base, val, index+startPoint, arr) &#125;) return base &#125; map 实现 function myMap(fn, thisArg = []) &#123; return this.reduce((prev, cur, index, arr) =&gt; &#123; return prev.concat(fn.call(thisArg, cur, index, arr)) &#125;, []) &#125; Promise 实现 const PENDING = &#39;pending&#39; const FULFILLED = &#39;fulfilled&#39; const REJECT = &#39;reject&#39; class Promise &#123; constructor () &#123; this.staus = PENDING this.value = &#39;&#39; this.reason = &#39;&#39; this.onResolvedCallBack = [] this.onRejectedCallBack = [] let resolve = (value) =&gt; &#123; if (this.status === PENDING) &#123; this.status = FULFILLED this.value = value this.onResolvedCallBack.forEach(fn =&gt; fn()) &#125; &#125; let reject = (reason) =&gt; &#123; if (this.status === PENDING) &#123; this.status = REJECT this.reason = reason this.onRejectedCallBack.forEach(fn =&gt; fn()) &#125; &#125; try &#123; exector(resolve, reject) &#125; catch(err) &#123; reject(err) &#125; &#125; then(onFulfilled, onRejected) &#123; if (this.status === FULFIllED) &#123; onFulfilled(this.value) &#125; if (this.status === REJECT) &#123; onRejected(this.reason) &#125; if (this.status === PENDING) &#123; this.onResolvedCallBack.push(() =&gt; onFulfilled(this.value)) this.onRejectedCallBack.push(() =&gt; onRejected(this.reason)) &#125; &#125; &#125; promiseAll function promiseAll(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let result = [] let count = 0 promises.forEach((promise, index) =&gt; &#123; promise.then(res =&gt; &#123; result.push(res) count++ if (count === promises.length) &#123; resolve(result) &#125; &#125;, err =&gt; reject(err)) &#125;) &#125;) &#125; promiseFinally function promiseFinally(cb) &#123; return this.then(value =&gt; &#123; return Promise.resolve(cb()).then(() =&gt; value) &#125;, err =&gt; &#123; return Promise.resolve(cb()).then(() =&gt; err) &#125;) &#125; promiseAllSetted function promiseAllSetted(promises) &#123; _promises = promises.map(item =&gt; item instanceof Promise ? item : Promise.resolve(item)) return new Promise((resolve, reject) =&gt; &#123; let result = [] let unSettedCount = _promise.length _promises.forEach((promise, index) =&gt; &#123; promise.then(res =&gt; &#123; result[index] = &#123; status: &#39;fulfilled&#39;, res &#125; unSettedCount-- unSettedCount === 0 &amp;&amp; resolve(result) &#125;, err =&gt; &#123; result[index] = &#123; status: &#39;reject&#39;, err &#125; unSettedCount-- unSettedCount === 0 &amp;&amp; reject(result) &#125;) &#125;) &#125;) &#125; promiseRace function promiseRace(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; promises.forEach(promise =&gt; &#123; promise.then(res =&gt; resolve(res), err =&gt; reject(err)) &#125;) &#125;) &#125; promiseAny function promiseAny(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let count = 0 promises.forEach(promise =&gt; &#123; promise.then(res =&gt; &#123; resolve(res) &#125;, err =&gt; &#123; count++ count === promises.length &amp;&amp; reject(err) &#125;) &#125;) &#125;) &#125; async&#x2F;await 自动执行器 function runGenerator(gen) &#123; return new Promise((resolve, reject) =&gt; &#123; let g = gen() function _next() &#123; let res try &#123; res = g.next(val) &#125; catch(err) &#123; return reject(err) &#125; if (res.done) &#123; return resolve(res.value) &#125; //res.value包装为promise，以兼容yield后面跟基本类型的情况 Promise.resolve(res.value).then(val =&gt; &#123; _next(val) &#125;, err =&gt; &#123; g.throw(err) &#125;) &#125; _next() &#125;) &#125; JSON.stringify 实现 function jsonStringify(data) &#123; let type = typeof data; if(type !== &#39;object&#39;) &#123; let result = data; //data 可能是基础数据类型的情况在这里处理 if (Number.isNaN(data) || data === Infinity) &#123; //NaN 和 Infinity 序列化返回 &quot;null&quot; result = &quot;null&quot;; &#125; else if (type === &#39;function&#39; || type === &#39;undefined&#39; || type === &#39;symbol&#39;) &#123; // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理 return undefined; &#125; else if (type === &#39;string&#39;) &#123; result = &#39;&quot;&#39; + data + &#39;&quot;&#39;; &#125; return String(result); &#125; else if (type === &#39;object&#39;) &#123; if (data === null) &#123; return &quot;null&quot; // 第01讲有讲过 typeof null 为&#39;object&#39;的特殊情况 &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &#39;function&#39;) &#123; return jsonStringify(data.toJSON()); &#125; else if (data instanceof Array) &#123; let result = []; //如果是数组，那么数组里面的每一项类型又有可能是多样的 data.forEach((item, index) =&gt; &#123; if (typeof item === &#39;undefined&#39; || typeof item === &#39;function&#39; || typeof item === &#39;symbol&#39;) &#123; result[index] = &quot;null&quot;; &#125; else &#123; result[index] = jsonStringify(item); &#125; &#125;); result = &quot;[&quot; + result + &quot;]&quot;; return result.replace(/&#39;/g, &#39;&quot;&#39;); &#125; else &#123; // 处理普通对象 let result = []; Object.keys(data).forEach((item, index) =&gt; &#123; if (typeof item !== &#39;symbol&#39;) &#123; //key 如果是 symbol 对象，忽略 if (data[item] !== undefined &amp;&amp; typeof data[item] !== &#39;function&#39; &amp;&amp; typeof data[item] !== &#39;symbol&#39;) &#123; //键值如果是 undefined、function、symbol 为属性值，忽略 result.push(&#39;&quot;&#39; + item + &#39;&quot;&#39; + &quot;:&quot; + jsonStringify(data[item])); &#125; &#125; &#125;); return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&#39;/g, &#39;&quot;&#39;); &#125; &#125; &#125; JSON.parse 实现 var json = &#39;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#39;; // obj 就是 json 反序列化之后得到的对象 var obj = eval(&quot;(&quot; + json + &quot;)&quot;);","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/zheng521/tags/interview/"}]}],"categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/zheng521/tags/interview/"}]}