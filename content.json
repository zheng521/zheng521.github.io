{"meta":{"title":"初见","subtitle":null,"description":null,"author":"zheng","url":"https://github.com/zheng521","root":"/"},"pages":[],"posts":[{"title":"必会手写代码","slug":"必会手写代码","date":"2023-04-01T04:33:14.000Z","updated":"2023-04-01T07:15:41.725Z","comments":true,"path":"2023/04/01/必会手写代码/","link":"","permalink":"https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/","excerpt":"","text":"new 实现 创建一个新对象 将新对象的原型属性指向构造函数的原型对象 将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 执行构造函数中的代码（为这个新对象添加属性） 返回新对象 (判断新对象是否为对象) &#96;&#96; function myNew(Func) &#123; let obj = &#123;&#125; obj._prop_ = Func.prototype let result = Func.apply(obj, arguments) return result instanceof Object ? result : obj &#125; instaceof 实现 function myInstaceOf(left, right) &#123; let prop = Object.getPrototypeOf(left) let prototype = right.prototype while (true) &#123; if (prop === null) return false if (prop === prototype) &#123; return true &#125; prop = Object.getPrototypeOf(prop) &#125; &#125; call 实现 function myCall(context) &#123; context = context || window context.fn = this let args = [...arguments].slice(1) let result = context.fn(...args) delete context.fn return result &#125; apply实现 function myApply(content) &#123; context = context || window context.fn = this let result if (arguments[1]) &#123; result = context.fn(...arguments[1]) &#125; else &#123; result = context.fn() &#125; return result &#125; bind实现 function myBind(context) &#123; let self = this let args = [...arguments].slice(1) return function () &#123; let newArgs = [...arguments] return self.apply(context, args.concat(newArgs)) &#125; &#125; currry实现 function curry(fn, ...args) &#123; if (args.length &gt; fn.length) &#123; fn(...args) &#125; else &#123; return (..._args) =&gt; curry(fn, ...args, ..._args) &#125; &#125; compose实现 const compose = (...fns) =&gt; val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val); function compose (...fns) &#123; return val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val) &#125; pipe实现 const pipe = (...fns) =&gt; val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val); function compose (...fns) &#123; return val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val) &#125; throttle function throttle(fn, delay) &#123; let timer = null return function (...args) &#123; if (!timer) &#123; timer = setTimeout(() =&gt; &#123; fn.apply(this, args) clearTimeout(timer) &#125;, delay) &#125; &#125; &#125; debounce function debounce(fn, time) &#123; let timer = null return function (...args) &#123; if (timer) clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(this, args) &#125;, time) &#125; &#125; object.Freeze 实现 function myFreeze(obj) &#123; if (obj instanceof Object) &#123; //封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置 Object.seal(obj) for (let p in obj) &#123; if (obj.hasOwnProperty(p)) &#123; Object.defineProperty(obj, p, &#123;writable: false&#125;) myFreeze(obj[p]) &#125; &#125; &#125; &#125; deepcopy function deepCopy(target, map = new WeakMap()) &#123; if (typeof(target) !== &#39;object&#39;) &#123; return &#125; if (map.get(target)) return map.get(target) let newObj = Array.isArray(target) ? [] : &#123;&#125; map.set(target, newObj) for (let key in target) &#123; if (targe.hasOwnProperty(key)) &#123; if (typeof(key) === &#39;object&#39;) &#123; newObj[key] = deepCopy(target[key]) &#125; else &#123; newObj[key] = target[key] &#125; &#125; &#125; return newObj &#125; arrayToTree 数组构建树形结构数据/** * 数组转树形结构 * @param &#123;array&#125; list 被转换的数组 * @param &#123;number|string&#125; root 根节点（最外层节点） * @returns array */ function arrayToTree(list, root) &#123; let map = &#123;&#125; for (let item of list) &#123; map[item.parentId] = item &#125; let result = [] for (let item of list) &#123; if (item.parentId === root) &#123; result.push(map[item.id]) &#125; else &#123; map[item.parentId].children = map[item.parentId].children ? map[item.parentId].push(map[item.id]) : (map[parent_id].children = [map[id]]) &#125; &#125; return result &#125; flattern function myFlattern(arr) &#123; return arr.reduce((prev, cur) =&gt; prev.concat(Array.isArray(cur) ? myFlattern(cur): cur),[]) &#125; reduce 实现 //语法 array.reduce(function(prev, currentValue, currentIndex, arr), initialValue) function myReduce(func, initVal) &#123; let arr = this let base = initVal ? initVal : arr[0] let startPoint = initVal ? 1 : 0 arr.slice(startPoint).forEach((val, index) =&gt; &#123; let base = func(base, val, index+startPoint, arr) &#125;) return base &#125; map 实现 function myMap(fn, thisArg = []) &#123; return this.reduce((prev, cur, index, arr) =&gt; &#123; return prev.concat(fn.call(thisArg, cur, index, arr)) &#125;, []) &#125;","categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/zheng521/tags/interview/"}]}],"categories":[],"tags":[{"name":"interview","slug":"interview","permalink":"https://github.com/zheng521/tags/interview/"}]}