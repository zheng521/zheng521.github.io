<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>初见</title>
  
  
  <link href="https://github.com/zheng521/atom.xml" rel="self"/>
  
  <link href="https://github.com/zheng521/"/>
  <updated>2023-04-02T04:02:15.105Z</updated>
  <id>https://github.com/zheng521/</id>
  
  <author>
    <name>zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试高频代码</title>
    <link href="https://github.com/zheng521/2023/04/02/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/zheng521/2023/04/02/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E4%BB%A3%E7%A0%81/</id>
    <published>2023-04-02T03:43:23.000Z</published>
    <updated>2023-04-02T04:02:15.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遍历节点生成虚拟Dom"><a href="#遍历节点生成虚拟Dom" class="headerlink" title="遍历节点生成虚拟Dom"></a>遍历节点生成虚拟Dom</h3><hr><pre><code>class Vnode &#123;  constructor(tag, data, value, type) &#123;    this.tag = tag  &amp;&amp; tag.toLowerCass()    this.data = data     this.value = value     this.type = type     this.children = []  &#125;  appendChild(vnode) &#123;    this.children.push(vnode)  &#125;&#125;function createVnode(node) &#123;  const nodeType = node.type   let _vnode = null   if (nodeType === 1) &#123;    const tagName = node.nodeName     const attrList = node.attributes    const attrData = &#123;&#125;    for (let i = 0; i &lt; attrList.length; i++) &#123;      attrData[attrList[i].nodeName] = attrList[i].nodeName    &#125;     _vnode = new Vnode(tagName, attrData, null, 1)    const childNodes = node.childNodes    for (let i = 0; i &lt; childNodes.length; i++) &#123;      _vnode.appendChild(createVnode(childNodes[i]))    &#125;  &#125; else if (nodeType === 3) &#123;    _vnode = new Vnode(null, node.nodeValue, value, 3)  &#125;  return _vnode&#125;</code></pre><h3 id="通过虚拟dom生成真实节点"><a href="#通过虚拟dom生成真实节点" class="headerlink" title="通过虚拟dom生成真实节点"></a>通过虚拟dom生成真实节点</h3><hr><pre><code>getRealNode(vnode) &#123;  const &#123; tag, data, value, type, children &#125; = vnode  let _node = null   if (type === 1) &#123;    _node = document.createElement(tag)    for (let key in data) &#123;      _node.setAttribute(key, data[key])    &#125;    for (let i = 0; i &lt; children.length; i++) &#123;      _node.appendChild(getRealNode(children[i]))    &#125;  &#125; else if (type === 3) &#123;    _node = document.createTextNode(value)  &#125;  return _node&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;遍历节点生成虚拟Dom&quot;&gt;&lt;a href=&quot;#遍历节点生成虚拟Dom&quot; class=&quot;headerlink&quot; title=&quot;遍历节点生成虚拟Dom&quot;&gt;&lt;/a&gt;遍历节点生成虚拟Dom&lt;/h3&gt;&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;class Vnode &amp;#123;
  </summary>
      
    
    
    
    
    <category term="interview" scheme="https://github.com/zheng521/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>必会手写代码(js基础)</title>
    <link href="https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</id>
    <published>2023-04-01T04:33:14.000Z</published>
    <updated>2023-04-02T03:35:53.057Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-实现"><a href="#new-实现" class="headerlink" title="new 实现"></a>new 实现</h3><hr><ol><li>创建一个新对象</li><li>将新对象的原型属性指向构造函数的原型对象</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象 (判断新对象是否为对象)</li></ol><p>  &#96;&#96;</p><pre><code>function myNew(Func) &#123;  let obj = &#123;&#125;  obj._prop_ = Func.prototype   let result = Func.apply(obj, arguments)  return  result instanceof Object ? result : obj&#125;</code></pre><h3 id="instaceof-实现"><a href="#instaceof-实现" class="headerlink" title="instaceof 实现"></a>instaceof 实现</h3><hr><pre><code>function myInstaceOf(left, right) &#123;  let prop = Object.getPrototypeOf(left)  let prototype = right.prototype  while (true) &#123;    if (prop === null) return false     if (prop === prototype) &#123;      return true    &#125;    prop = Object.getPrototypeOf(prop)  &#125;&#125;</code></pre><h3 id="call-实现"><a href="#call-实现" class="headerlink" title="call 实现"></a>call 实现</h3><hr><pre><code>function myCall(context) &#123;  context = context || window   context.fn = this   let args = [...arguments].slice(1)  let result = context.fn(...args)  delete context.fn  return result&#125;</code></pre><h3 id="apply实现"><a href="#apply实现" class="headerlink" title="apply实现"></a>apply实现</h3><hr><pre><code>function myApply(content) &#123;  context = context || window   context.fn = this   let result   if (arguments[1]) &#123;    result = context.fn(...arguments[1])  &#125; else &#123;    result = context.fn()  &#125;  return result&#125;</code></pre><h3 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h3><hr><pre><code>function myBind(context) &#123;  let self = this   let args = [...arguments].slice(1)  return function () &#123;    let newArgs = [...arguments]    return self.apply(context, args.concat(newArgs))  &#125;&#125;</code></pre><h3 id="currry实现"><a href="#currry实现" class="headerlink" title="currry实现"></a>currry实现</h3><hr><pre><code>function curry(fn, ...args) &#123;  if (args.length &gt; fn.length) &#123;    fn(...args)  &#125; else &#123;    return (..._args) =&gt; curry(fn, ...args, ..._args)  &#125;&#125;</code></pre><h3 id="compose实现"><a href="#compose实现" class="headerlink" title="compose实现"></a>compose实现</h3><hr><pre><code>const compose = (...fns) =&gt; val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val);function compose (...fns) &#123;  return val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val)&#125;</code></pre><h3 id="pipe实现"><a href="#pipe实现" class="headerlink" title="pipe实现"></a>pipe实现</h3><hr><pre><code>const pipe = (...fns) =&gt; val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val);function compose (...fns) &#123;  return val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val)&#125;</code></pre><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><hr><pre><code>function throttle(fn, delay) &#123;  let timer = null  return function (...args) &#123;    if (!timer) &#123;      timer = setTimeout(() =&gt; &#123;        fn.apply(this, args)        clearTimeout(timer)      &#125;, delay)    &#125;  &#125;&#125;</code></pre><h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h3><hr><pre><code>function debounce(fn, time) &#123;  let timer = null   return function (...args) &#123;    if (timer) clearTimeout(timer)    timer = setTimeout(() =&gt; &#123;      fn.apply(this, args)    &#125;, time)  &#125;&#125;</code></pre><h3 id="object-Freeze-实现"><a href="#object-Freeze-实现" class="headerlink" title="object.Freeze 实现"></a>object.Freeze 实现</h3><hr><pre><code>  function myFreeze(obj) &#123;    if (obj instanceof Object) &#123;      //封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置      Object.seal(obj)      for (let p in obj) &#123;        if (obj.hasOwnProperty(p)) &#123;          Object.defineProperty(obj, p, &#123;writable: false&#125;)          myFreeze(obj[p])        &#125;      &#125;    &#125;  &#125;</code></pre><h3 id="deepcopy"><a href="#deepcopy" class="headerlink" title="deepcopy"></a>deepcopy</h3><hr><pre><code>  function deepCopy(target, map = new WeakMap()) &#123;    if (typeof(target) !== &#39;object&#39;) &#123;      return     &#125;    if (map.get(target)) return map.get(target)    let newObj = Array.isArray(target) ? [] : &#123;&#125;    map.set(target, newObj)    for (let key in target) &#123;      if (targe.hasOwnProperty(key)) &#123;        if (typeof(key) === &#39;object&#39;) &#123;          newObj[key] = deepCopy(target[key])        &#125; else &#123;          newObj[key] = target[key]        &#125;      &#125;    &#125;    return newObj  &#125;</code></pre><h3 id="arrayToTree-数组构建树形结构数据"><a href="#arrayToTree-数组构建树形结构数据" class="headerlink" title="arrayToTree 数组构建树形结构数据"></a>arrayToTree 数组构建树形结构数据</h3><pre><code>/**   * 数组转树形结构   * @param &#123;array&#125; list 被转换的数组   * @param &#123;number|string&#125; root 根节点（最外层节点）   * @returns array   */function arrayToTree(list, root) &#123;  let map = &#123;&#125;  for (let item of list) &#123;    map[item.parentId] = item  &#125;  let result = []  for (let item of list) &#123;    if (item.parentId === root) &#123;      result.push(map[item.id])    &#125; else &#123;      map[item.parentId].children = map[item.parentId].children ? map[item.parentId].push(map[item.id]) :      (map[parent_id].children = [map[id]])    &#125;  &#125;  return result&#125;</code></pre><h3 id="flattern"><a href="#flattern" class="headerlink" title="flattern"></a>flattern</h3><hr><pre><code>function myFlattern(arr) &#123;  return arr.reduce((prev, cur) =&gt; prev.concat(Array.isArray(cur) ? myFlattern(cur):   cur),[])&#125;</code></pre><h3 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><hr><pre><code>//语法 array.reduce(function(prev, currentValue, currentIndex, arr), initialValue)function myReduce(func, initVal) &#123;  let arr = this   let base = initVal ? initVal : arr[0]  let startPoint = initVal ? 1 : 0   arr.slice(startPoint).forEach((val, index) =&gt; &#123;    let base = func(base, val, index+startPoint, arr)  &#125;)  return base&#125;</code></pre><h3 id="map-实现"><a href="#map-实现" class="headerlink" title="map 实现"></a>map 实现</h3><hr><pre><code>function myMap(fn, thisArg = []) &#123;  return this.reduce((prev, cur, index, arr) =&gt; &#123;    return prev.concat(fn.call(thisArg, cur, index, arr))  &#125;, [])&#125;</code></pre><h3 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h3><hr><pre><code>  const PENDING = &#39;pending&#39;  const FULFILLED = &#39;fulfilled&#39;  const REJECT = &#39;reject&#39;  class Promise &#123;    constructor () &#123;      this.staus = PENDING      this.value = &#39;&#39;      this.reason = &#39;&#39;      this.onResolvedCallBack = []      this.onRejectedCallBack = []      let resolve = (value) =&gt; &#123;        if (this.status === PENDING) &#123;          this.status = FULFILLED           this.value = value          this.onResolvedCallBack.forEach(fn =&gt; fn())        &#125;      &#125;       let reject = (reason) =&gt; &#123;        if (this.status === PENDING) &#123;          this.status = REJECT           this.reason = reason          this.onRejectedCallBack.forEach(fn =&gt; fn())        &#125;      &#125;      try &#123;        exector(resolve, reject)      &#125; catch(err) &#123;        reject(err)      &#125;    &#125;    then(onFulfilled, onRejected) &#123;      if (this.status === FULFIllED) &#123;        onFulfilled(this.value)      &#125;      if (this.status === REJECT) &#123;        onRejected(this.reason)      &#125;      if (this.status === PENDING) &#123;        this.onResolvedCallBack.push(() =&gt; onFulfilled(this.value))        this.onRejectedCallBack.push(() =&gt; onRejected(this.reason))      &#125;    &#125;  &#125;  </code></pre><h3 id="promiseAll"><a href="#promiseAll" class="headerlink" title="promiseAll"></a>promiseAll</h3><hr><pre><code>function promiseAll(promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let result = []    let count = 0     promises.forEach((promise, index) =&gt; &#123;      promise.then(res =&gt; &#123;        result.push(res)        count++        if (count === promises.length) &#123;          resolve(result)        &#125;      &#125;, err =&gt; reject(err))    &#125;)  &#125;)&#125;</code></pre><h3 id="promiseFinally"><a href="#promiseFinally" class="headerlink" title="promiseFinally"></a>promiseFinally</h3><hr><pre><code>function promiseFinally(cb) &#123;  return this.then(value =&gt; &#123;    return Promise.resolve(cb()).then(() =&gt; value)  &#125;, err =&gt; &#123;    return Promise.resolve(cb()).then(() =&gt; err)  &#125;)&#125;</code></pre><h3 id="promiseAllSetted"><a href="#promiseAllSetted" class="headerlink" title="promiseAllSetted"></a>promiseAllSetted</h3><hr><pre><code>function promiseAllSetted(promises) &#123;  _promises = promises.map(item =&gt; item instanceof Promise ? item : Promise.resolve(item))  return new Promise((resolve, reject) =&gt; &#123;    let result = []    let unSettedCount = _promise.length    _promises.forEach((promise, index) =&gt; &#123;      promise.then(res =&gt; &#123;        result[index] = &#123;          status: &#39;fulfilled&#39;,           res        &#125;        unSettedCount--        unSettedCount === 0 &amp;&amp; resolve(result)      &#125;, err =&gt; &#123;        result[index] = &#123;          status: &#39;reject&#39;,           err        &#125;        unSettedCount--        unSettedCount === 0 &amp;&amp; reject(result)      &#125;)    &#125;)  &#125;)&#125;</code></pre><h3 id="promiseRace"><a href="#promiseRace" class="headerlink" title="promiseRace"></a>promiseRace</h3><hr><pre><code>function promiseRace(promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    promises.forEach(promise =&gt; &#123;      promise.then(res =&gt; resolve(res), err =&gt; reject(err))    &#125;)  &#125;)&#125;</code></pre><h3 id="promiseAny"><a href="#promiseAny" class="headerlink" title="promiseAny"></a>promiseAny</h3><hr><pre><code>function promiseAny(promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let count = 0     promises.forEach(promise =&gt; &#123;      promise.then(res =&gt; &#123;        resolve(res)      &#125;, err =&gt; &#123;        count++         count === promises.length &amp;&amp; reject(err)      &#125;)    &#125;)  &#125;)&#125;</code></pre><h3 id="async-x2F-await-自动执行器"><a href="#async-x2F-await-自动执行器" class="headerlink" title="async&#x2F;await  自动执行器"></a>async&#x2F;await  自动执行器</h3><hr><pre><code>  function runGenerator(gen) &#123;    return new Promise((resolve, reject) =&gt; &#123;      let g = gen()      function _next() &#123;        let res        try &#123;          res = g.next(val)        &#125; catch(err) &#123;          return reject(err)        &#125;        if (res.done) &#123;          return resolve(res.value)        &#125;        //res.value包装为promise，以兼容yield后面跟基本类型的情况        Promise.resolve(res.value).then(val =&gt; &#123;          _next(val)        &#125;, err =&gt; &#123;          g.throw(err)        &#125;)      &#125;      _next()    &#125;)  &#125;</code></pre><h3 id="JSON-stringify-实现"><a href="#JSON-stringify-实现" class="headerlink" title="JSON.stringify 实现"></a>JSON.stringify 实现</h3><hr><pre><code>function jsonStringify(data) &#123;  let type = typeof data;  if(type !== &#39;object&#39;) &#123;    let result = data;    //data 可能是基础数据类型的情况在这里处理    if (Number.isNaN(data) || data === Infinity) &#123;      //NaN 和 Infinity 序列化返回 &quot;null&quot;      result = &quot;null&quot;;    &#125; else if (type === &#39;function&#39; || type === &#39;undefined&#39; || type === &#39;symbol&#39;) &#123;      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理      return undefined;    &#125; else if (type === &#39;string&#39;) &#123;      result = &#39;&quot;&#39; + data + &#39;&quot;&#39;;    &#125;    return String(result);  &#125; else if (type === &#39;object&#39;) &#123;    if (data === null) &#123;        return &quot;null&quot;  // 第01讲有讲过 typeof null 为&#39;object&#39;的特殊情况    &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &#39;function&#39;) &#123;        return jsonStringify(data.toJSON());    &#125; else if (data instanceof Array) &#123;        let result = [];        //如果是数组，那么数组里面的每一项类型又有可能是多样的        data.forEach((item, index) =&gt; &#123;        if (typeof item === &#39;undefined&#39; || typeof item === &#39;function&#39; || typeof item === &#39;symbol&#39;) &#123;              result[index] = &quot;null&quot;;          &#125; else &#123;              result[index] = jsonStringify(item);          &#125;        &#125;);        result = &quot;[&quot; + result + &quot;]&quot;;        return result.replace(/&#39;/g, &#39;&quot;&#39;);      &#125; else &#123;        // 处理普通对象        let result = [];        Object.keys(data).forEach((item, index) =&gt; &#123;            if (typeof item !== &#39;symbol&#39;) &#123;              //key 如果是 symbol 对象，忽略              if (data[item] !== undefined &amp;&amp; typeof data[item] !== &#39;function&#39; &amp;&amp; typeof data[item] !== &#39;symbol&#39;) &#123;                //键值如果是 undefined、function、symbol 为属性值，忽略                result.push(&#39;&quot;&#39; + item + &#39;&quot;&#39; + &quot;:&quot; + jsonStringify(data[item]));              &#125;            &#125;        &#125;);        return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&#39;/g, &#39;&quot;&#39;);        &#125;    &#125;&#125;</code></pre><h3 id="JSON-parse-实现"><a href="#JSON-parse-实现" class="headerlink" title="JSON.parse 实现"></a>JSON.parse 实现</h3><hr><pre><code>var json = &#39;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#39;;// obj 就是 json 反序列化之后得到的对象var obj = eval(&quot;(&quot; + json + &quot;)&quot;); </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-实现&quot;&gt;&lt;a href=&quot;#new-实现&quot; class=&quot;headerlink&quot; title=&quot;new 实现&quot;&gt;&lt;/a&gt;new 实现&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新对象&lt;/li&gt;
&lt;li&gt;将新对象的原型属性指向构造函数的原型对象&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="interview" scheme="https://github.com/zheng521/tags/interview/"/>
    
  </entry>
  
</feed>
