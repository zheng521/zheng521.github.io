<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>初见</title>
  
  
  <link href="https://github.com/zheng521/atom.xml" rel="self"/>
  
  <link href="https://github.com/zheng521/"/>
  <updated>2023-07-09T08:25:31.065Z</updated>
  <id>https://github.com/zheng521/</id>
  
  <author>
    <name>zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重载</title>
    <link href="https://github.com/zheng521/2023/07/09/%E9%87%8D%E8%BD%BD/"/>
    <id>https://github.com/zheng521/2023/07/09/%E9%87%8D%E8%BD%BD/</id>
    <published>2023-07-09T06:30:00.000Z</published>
    <updated>2023-07-09T08:25:31.065Z</updated>
    
    <content type="html"><![CDATA[<h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>函数重载（英语：function overloading）或方法重载，是某些编程语言（如 C++、C#、Java、Swift、Kotlin 等）具有的一项特性，该特性允许创建多个具有不同实现的同名函数。对重载函数的调用会运行其适用于调用上下文的具体实现，即允许一个函数调用根据上下文执行不同的任务。</p></blockquote><h3 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h3><ul><li>多个函数定义使用相同的函数名称</li><li>函数参数的数量或类型必须有区别</li></ul><h4 id="java-中的重载"><a href="#java-中的重载" class="headerlink" title="java 中的重载"></a>java 中的重载</h4><p>  重载可以理解成多态的具体表现形式。<br>  在一个类中，我们可以定义多个方法。如果有一系列方法，它们的功能都是类似的，只有参数有所不同，那么，可以把这一组方法名做成同名方法。<br>  这种方法名相同，但各自的参数不同，称为方法重载（Overload）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hi, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  注意：方法重载的返回值类型通常都是相同的。<br>  方法重载的目的是，功能类似的方法使用同一名字，更容易记住，因此，调用起来更简单。</p><h4 id="TypeScript-重载"><a href="#TypeScript-重载" class="headerlink" title="TypeScript 重载"></a>TypeScript 重载</h4><p>JavaScript 作为动态语言， 是没有重载这一说的。一是它的参数没有类型的区分，二是对参数个数也没有检查。虽然语言层面无法自动进行重载，但借助其动态的特性，我们可以在代码中手动检查入参的类型，或者通过 arguments 获取到参数个数，从而实现根据不同的入参做不同的操作。</p><h5 id="重载的理解"><a href="#重载的理解" class="headerlink" title="重载的理解"></a>重载的理解</h5><p>用于实现不同参数输入并且对应不同参数输出的函数，在前面定义多个重载签名，一个实现签名，一个函数体构造，重载签名主要是精确显示函数的输入输出，实现签名主要是将所有的输入输出类型做一个全量定义，防止TS编译报错，函数体就是整个整个函数实现的全部逻辑。</p><h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">all: number</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">topAndBottom: number, leftAndRight: number</span>)</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">top: number, right: number, bottom: number, left: number</span>)</span><br><span class="line"><span class="comment">// 1/实际的函数体应该包含函数重载的所有情况</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">padding</span>(<span class="params">a: number, b?: number, c?: number, d?: number</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (b === <span class="literal">undefined</span> &amp;&amp; c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    b = c = d = a</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c === <span class="literal">undefined</span> &amp;&amp; d === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    c = a</span><br><span class="line">    d = b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">top</span>: a,</span><br><span class="line">    <span class="attr">right</span>: b,</span><br><span class="line">    <span class="attr">bottom</span>: c,</span><br><span class="line">    <span class="attr">left</span>: d,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">padding (<span class="number">1</span>);  <span class="comment">// 正确： all</span></span><br><span class="line"><span class="comment">// 匹配第 1个重载</span></span><br><span class="line">padding (<span class="number">1</span>, <span class="number">1</span>);  <span class="comment">// 正确： topAndBottom, leftAndRight</span></span><br><span class="line"><span class="comment">// 匹配第 2个重载</span></span><br><span class="line">padding (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)； <span class="comment">//正确：top、 right, bottom, left</span></span><br><span class="line"><span class="comment">// 匹配第3个重载</span></span><br><span class="line">padding (<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)  <span class="comment">//错误： Not a part of the available overloads</span></span><br></pre></td></tr></table></figure><p>注意：<br>Typescript 中的西数重载没有任何运行时的开销。它只允许记录你希望的调用函数的方式，并且编译器会检查其余代码.</p><p>通过鼠标点击实际调用方法 padding(1),command+鼠标右键，他会自动解析跳转到number这个重载签名上面去，很直观的知道如何调用的。</p><h6 id="重载过程"><a href="#重载过程" class="headerlink" title="重载过程"></a>重载过程</h6><p>TypeScript 重载的过程是，拿传入的参数和重载的方法签名列表中由上往下逐个匹配，直到找到一个完全匹配的函数签名，否则报错。所以推荐的做法是将签名更加具体的重载放上面，不那么具体的放后面。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params">type: MessageType, count?: number</span>): <span class="title class_">Message</span>[];</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params">id: number</span>): <span class="title class_">Message</span> | <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//bad </span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params">id: number</span>): <span class="title class_">Message</span> | <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getMessage</span>(<span class="params">type: MessageType, count?: number</span>): <span class="title class_">Message</span>[];</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">class</span> <span class="title class_">ArrayEN</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">public arr: object[]</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">get</span>(<span class="params">Index: number</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">arr</span>[<span class="title class_">Index</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="attr">value</span>: number): number;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="attr">value</span>: object): object;</span><br><span class="line">  <span class="title function_">delete</span>(<span class="attr">value</span>: number | object): number | object &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">arr</span> = <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value !== index;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value !== item;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="构造器重载"><a href="#构造器重载" class="headerlink" title="构造器重载"></a>构造器重载</h5><p>构造器是没有返回值的，他会隐式返回一个this，这个this会分配给new对象的左边的变量，至此所有的this都是指向的当前正在使用的对象。<br>构造器重载和函数重载使基本相同，主要区别是：TS 类构造器重载签名和实现签名都不需要管理返回值，TS 构造器是在对象创建出来之后，但是还没有赋值给对象变量之前被执行，一般用来给对象属性赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  interface <span class="title class_">OJType</span>&#123;</span><br><span class="line">    width?:number,</span><br><span class="line">    height?:number</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Graph</span>&#123;</span><br><span class="line">    public <span class="attr">width</span>:number;</span><br><span class="line">    public <span class="attr">height</span>:number;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">width?:number,height?:number</span>)</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">side?:OJType</span>)</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">v1:any,v2?:any</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> v1===<span class="string">&#x27;object&#x27;</span>)&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">width</span>=v1.<span class="property">width</span>;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">height</span>=v1.<span class="property">height</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">width</span>=v1;</span><br><span class="line">            <span class="variable language_">this</span>.<span class="property">height</span>=v2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">getArea</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;width,height&#125;=<span class="variable language_">this</span>;</span><br><span class="line">        <span class="keyword">return</span> width*height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> g=<span class="keyword">new</span> <span class="title class_">Graph</span>(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(g.<span class="title function_">getArea</span>())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="扩散"><a href="#扩散" class="headerlink" title="扩散"></a>扩散</h3><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>  方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。</p><ul><li>方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li><li>方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li><li>方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。</li></ul><p>  <img src="/./img/over_load.png"><br>  <img src="/./img/over_load2.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;重载&quot;&gt;&lt;a href=&quot;#重载&quot; class=&quot;headerlink&quot; title=&quot;重载&quot;&gt;&lt;/a&gt;重载&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;block</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>react基础</title>
    <link href="https://github.com/zheng521/2023/04/05/react%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/zheng521/2023/04/05/react%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-05T02:42:06.000Z</published>
    <updated>2023-04-06T06:14:15.968Z</updated>
    
    <content type="html"><![CDATA[<h2 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h2><p><img src="/images/react-lifecycle.jpg"></p><h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>⏱ 触发时机：在组件初始化的时候触发一次。<br>💡 使用建议：</p><ul><li>设置初始化状态：因为组件的生命周期中任何函数都可能要访问 State，那么整个周期中第一个被调用的构造函数便是初始化 state 最理想的地方；</li><li>绑定成员函数上下文引用：<ul><li>因为在 ES6 语法下，类的每个成员函数在执行时的 this 并不是和类实例自动绑定的；</li><li>而在构造函数中 this 就是当前组件实例，所以，为了方便将来调用，往往在构造函数中将这个实例的特定函数绑定 this 为当前类实例；</li><li>建议定义函数方法时直接使用箭头函数，就无须在构造函数中进行函数的 bind 操作。</li></ul></li></ul><h2 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps"></a>static getDerivedStateFromProps</h2><p>⏱ 触发时机：该函数会在组件化实例化后和重新渲染前调用（生成 VirtualDOM 之后，实际 DOM 挂载之前），意味着无论是父组件的更新、props 的变化或通过 setState 更新组件内部的 State，它都会被调用。</p><p>🔙 返回值：该生命周期函数必须有返回值，它需要返回一个对象来更新 State，或者返回 null 来表明新 props 不需要更新任何 state。</p><p>🆕 新特性：当组件实例化时，该方法替代了 componentWillMount，而当接收新的 props 时，该方法替代了 componentWillReceiveProps 和 componentWillUpdate。</p><p>⚠️ 注意事项：</p><ul><li>在组件装载和更新阶段都会触发。</li><li>如果父组件导致了组件的重新渲染，即使属性没有更新，这一方法也会被触发；</li><li>如果你只想处理 props 的前后变化，你需要将上一个 props 值存到 state 里作为镜像；</li><li>该生命周期函数是一个静态函数，所以函数体内无法访问指向当前组件实例的指针 this；<br>当需要更新 state 时，需要返回一个对象，否则，返回一个 null</li></ul><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>它是一个仅仅用于渲染的纯函数，返回值完全取决于 state 和 props，不能在函数中任何修改 state、props、请求数据等具有副作用的操作，不能读写 DOM 信息，也不能和浏览器进行交互（例如 setTimeout）。如果需要和浏览器交互，在 componentDidMount() 中或者其它生命周期方法完成相关事务。</p><p>⚠️ 注意事项：</p><ul><li>请勿在此函数中使用 setState 方法；</li><li>请勿在此函数中修改 props、state 以及数据请求等具有副作用的操作。</li></ul><h2 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h2><p>⏱ 触发时机：组件完全挂载到网页上后触发。</p><p>🎉 适用场景：发送网络请求；任何依赖于 DOM 的初始化操作；添加事件监听；如果使用了 Redux 之类的数据管理工具，也能触发 action 处理数据变化逻辑。</p><p>🔬深入研究：该函数不会在 render 函数调用完成之后立即触发，因为 render 函数仅仅是返回了 JSX 的对象，并没有立即挂载到 DOM 树上，而该生命周期函数是在<strong>组件被渲染到 DOM 树（称为初始化渲染）</strong>之后触发的。</p><p>⚠️ 注意事项：该生命周期函数在进行服务器端渲染时不会触发（仅客户端有效）。</p><h2 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h2><p>⏱ 触发时机：每次组件因为 state 和 props 变化而更新时，在重新渲染前该生命周期函数都会触发，让 React 知道当前 state 或 props 的改变是否影响组件的输出（渲染）。</p><p>🔙 返回值：根据逻辑判断返回 true 表示继续进行组件渲染，否则将停止组件渲染过程。默认返回 true，也就是说，只要组件触发了更新，组件就一定会更新。</p><p>🔬深入研究：在一个更新生命周期中，组件及其子组件将根据该方法返回的布尔值来决定是否继续这次更新过程（重新渲染）。这样你可以在必要的时候阻止组件的渲染生命周期（Render Lifecycle）方法，避免不必要的渲染。</p><p>⚠️ 注意事项：</p><p>此钩子函数在初始化渲染和使用了 forceUpdate 方法的情况下不会被触发，使用 forceUpdate 会强制更新</p><p>请勿在此函数中使用 setState 方法，会导致循环调用。</p><h2 id="getSnapshotBeforeUpdate"><a href="#getSnapshotBeforeUpdate" class="headerlink" title="getSnapshotBeforeUpdate"></a>getSnapshotBeforeUpdate</h2><p>⏱ 触发时机：该生命周期函数会在组件即将挂载时触发，它的触发在 render 渲染函数之后。由此可见，render 函数并没有完成挂载操作，而是进行构建抽象 UI（也就是 Virtual DOM）的工作。该生命周期函数执行完毕后就会立即触发 componentDidUpdate 生命周期钩子。</p><p>🎉 适用场景：该生命周期函数能让你捕获某些从 DOM 中才能获取的（可能会变更的）信息（例如，元素重新渲染后页面各种定位位置的变更等）。</p><p>作用：比如网页滚动位置，不需要它持久化，只需要在组件更新以后能够恢复原来的位置即可。</p><p>⚠️ 注意事项：</p><ul><li>该生命周期函数返回的值将作为第三个参数传递给 componentDidUpdate，我们可以利用这个通道保存一些不需要持久化的状态，用完即可舍弃。（这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。）</li><li>该函数的出现是为了 React 17 的异步渲染而准备的</li></ul><h2 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h2><p>⏱ 触发时机：组件每次重新渲染后触发，相当于首次渲染（初始化）之后触发 componentDidMount ，</p><p>🎉 适用场景：操作 DOM；发送网络请求。</p><p>⚠️ 注意事项：</p><ul><li>将原先写在 componentWilUpdate 中的回调迁移至 componentDidUpdate，将以前放在 componentWillReceiveProps 中的异步网络请求放在 componentDidUpdate 中。</li><li>在该生命周期中使用 setState 时，必须加 if 条件判断，通过判断 prevProps、prevState 和 this.state 之间的数据变化，来判断是否执行相关的 state 变更逻辑，这使得尽管在 componentDidUpdate 中调用了 setState 进行再更新，但是直至条件不成立，就不会造成程序死循环。</li><li>此生命周期函数不会在初始化渲染的时候触发。</li></ul><h2 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h2><p>⏱ 触发时机：在组件卸载和销毁之前触发。可以利用这个生命周期方法去执行任何清理任务。</p><p>🎉 适用场景：用于注销事件监听器；取消网络请求；取消定时器；解绑 DOM 事件。</p><p>⚠️ 注意事项：在该方法中调用 setState 不会触发 render，因为所有的更新队列，更新状态都被重置为 null。</p><h2 id="static-getDerivedStateFromError"><a href="#static-getDerivedStateFromError" class="headerlink" title="static getDerivedStateFromError"></a>static getDerivedStateFromError</h2><p>⏱ 触发时机：该生命周期函数会在子孙组件抛出错误时执行。</p><p>🔙 返回值：它接收抛出的错误作为参数并且需要返回值用于更新 State。</p><p>💡 使用建议：</p><ul><li>该生命周期函数中可用于修改 state 以显示错误提醒的 UI，或者将错误信息发送到服务端进行 Log 用于后期分析；</li><li>在捕获到错误的瞬间，React 会在这次渲染周期中将这个组件渲染为 null，这就有可能导致他的父组件设置他上面的 ref 获得 null 而导致一些问题；</li></ul><h2 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch"></a>componentDidCatch</h2><p>  ⏱ 触发时机：该生命周期函数会在子孙组件抛出错误时触发。</p><p>⚠️ 注意事项：错误边界只能捕捉生命周期中的错误（componentWillMount &#x2F; render 等方法在内）。无法捕捉异步、事件回调中的错误，要捕捉和覆盖所有场景依然需要配合 window.onerror、Promise.catch、try&#x2F;catch 等方式。</p><hr><h2 id="父子生命周期"><a href="#父子生命周期" class="headerlink" title="父子生命周期"></a>父子生命周期</h2><h4 id="首次渲染过程"><a href="#首次渲染过程" class="headerlink" title="首次渲染过程"></a>首次渲染过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父constructor-&gt;父getDerivedStateFromProps-&gt;父renders-&gt;子constructor-&gt;子getDerivedStateFromProps-&gt;子renders-&gt;子componentDidMount-&gt;父componentDidMount</span><br></pre></td></tr></table></figure><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父getDerivedStateFromPops-&gt;父shouldComponentUpdate-&gt;父render-&gt;子getDerivedStateFromPops-&gt;子shouldComponentUpdate-&gt;子render-&gt;子getSnapshotBeforeUpdate-&gt;父getSnapshotBeforeUpdate-&gt;子componentDidUpdate-&gt;父子componentDidUpdate</span><br></pre></td></tr></table></figure><h4 id="卸载过程"><a href="#卸载过程" class="headerlink" title="卸载过程"></a>卸载过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父getDerivedStateFromPops-&gt;父shouldComponentUpdate-&gt;父render-&gt;父getSnapshotBeforeUpdate-&gt;子componentWillUnmount-&gt;父componentDidUpdate</span><br></pre></td></tr></table></figure><h3 id="父子组件生命周期执行顺序总结："><a href="#父子组件生命周期执行顺序总结：" class="headerlink" title="父子组件生命周期执行顺序总结："></a>父子组件生命周期执行顺序总结：</h3><ul><li><p>当子组件自身状态改变时，不会对父组件产生副作用的情况下，父组件不会进行更新，即不会触发父组件的生命周期</p></li><li><p>当父组件中状态发生变化（包括子组件的挂载以及卸载）时，会触发自身对应的生命周期以及子组件的更新</p><ul><li><code>render</code>  以及 <code>render</code> 之前的生命周期，则 父组件先执行</li><li><code>render</code> 之后的声明周期，则子组件先执行，并且是与父组件交替执行</li></ul></li></ul><p>当子组件进行卸载时，只会执行自身的 componentWillUnmount 生命周期，不会再触发别的生命周期</p><h2 id="react-优化"><a href="#react-优化" class="headerlink" title="react 优化"></a>react 优化</h2><ul><li>循环使用 key</li><li>修改 css 模拟 <code>v-show</code></li><li>使用 Fragment 减少层级</li><li>JSX 中不要定义函数</li><li>在构造函数 bind this</li><li>使用 shouldComponentUpdate 控制组件渲染</li><li>React.memo 缓存函数组件</li><li>useMemo 缓存数据</li><li>异步组件</li><li>路由懒加载</li><li>SSR</li></ul><h2 id="react遇到的坑"><a href="#react遇到的坑" class="headerlink" title="react遇到的坑"></a>react遇到的坑</h2><ul><li>JSX 中，自定义组件命名，开头字母要大写，html 标签开头字母小写</li><li>JSX 中 <code>for</code> 写成 <code>htmlFor</code> ， <code>class</code> 写成 <code>className</code></li><li>state 作为不可变数据，不可直接修改，使用纯函数</li><li>JSX 中，属性要区分 JS 表达式和字符串<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Demo</span> position=&#123;<span class="number">1</span>&#125; flag=&#123;<span class="literal">true</span>&#125;/&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Demo</span> <span class="attr">position</span>=<span class="string">&quot;1&quot;</span> <span class="attr">flag</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span></span><br></pre></td></tr></table></figure></li><li>state 是异步更新的，要在 callback 中拿到最新的 state 值<br>React Hooks 有很多限制，注意不到就会踩坑。例如，<code>useEffect</code> 内部不能修改 state</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> timer = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">setCount</span>(count + <span class="number">1</span>) <span class="comment">// 如果依赖是 [] ，这里 setCount 不会成功</span></span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    &#125;, [count]) <span class="comment">// 只有依赖是 [count] 才可以，这样才会触发组件 update</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>count: &#123;count&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span></span><br></pre></td></tr></table></figure><ul><li>再例如，<code>useEffect</code> 依赖项（即第二个参数）里有对象、数组，就会出现死循环。所以，依赖项里都要是值类型。<br><br>因为 React Hooks 是通过 <code>Object.is</code> 进行依赖项的前后比较。如果是值类型，则不妨碍。<br>如果是引用类型，前后的值是不一样的（纯函数，每次新建值），就类似 <code>&#123;x:100&#125; !== &#123;x:100&#125;</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;, [obj, arr])</span><br></pre></td></tr></table></figure><hr><h2 id="React-错误监听"><a href="#React-错误监听" class="headerlink" title="React 错误监听"></a>React 错误监听</h2><ul><li><h2 id="ErrorBoundary"><a href="#ErrorBoundary" class="headerlink" title="ErrorBoundary"></a>ErrorBoundary</h2></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;react-生命周期&quot;&gt;&lt;a href=&quot;#react-生命周期&quot; class=&quot;headerlink&quot; title=&quot;react 生命周期&quot;&gt;&lt;/a&gt;react 生命周期&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/react-lifecycle.jpg&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue基础</title>
    <link href="https://github.com/zheng521/2023/04/05/vue%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/zheng521/2023/04/05/vue%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-05T02:41:49.000Z</published>
    <updated>2023-04-06T05:59:20.293Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vue-生命周期"><a href="#vue-生命周期" class="headerlink" title="vue 生命周期"></a>vue 生命周期</h2><p><img src="/images/vue-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><p>初始化一个空的 Vue 实例，<code>data</code> <code>methods</code> 等尚未被初始化，无法调用。</p><h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><p>Vue 实例初始化完成，<code>data</code> <code>methods</code> 都已初始化完成，可调用。<br><br>但尚未开始渲染模板。</p><h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><p>编译模板，调用 <code>render</code> 函数生成 vdom ，但还没有开始渲染 DOM</p><h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><p>渲染 DOM 完成，页面更新。组件创建完成，开始进入运行阶段。</p><h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><p>在数据发生改变后，DOM 被更新之前被调用。这里适合在现有 DOM 将要被更新之前访问它，比如移除手动添加的事件监听器。</p><h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><p>在数据更改导致的虚拟 DOM 重新渲染和更新完毕之后被调用。</p><p>注意，尽量不要在 <code>updated</code> 中继续修改数据，否则可能会触发死循环。</p><h2 id="onActivated"><a href="#onActivated" class="headerlink" title="onActivated"></a>onActivated</h2><p>被 <code>keep-alive</code> 缓存的组件激活时调用。</p><h2 id="onDeactivated"><a href="#onDeactivated" class="headerlink" title="onDeactivated"></a>onDeactivated</h2><p>被 <code>keep-alive</code> 缓存的组件停用时调用。</p><h2 id="beforeUnmount"><a href="#beforeUnmount" class="headerlink" title="beforeUnmount"></a>beforeUnmount</h2><p>组件进入销毁阶段。</p><p>卸载组件实例后调用，在这个阶段，实例仍然是完全正常的。<br><br>移除、解绑一些全局事件、自定义事件，可以在此时操作。</p><h2 id="unmounted"><a href="#unmounted" class="headerlink" title="unmounted"></a>unmounted</h2><p>卸载组件实例后调用。调用此钩子时，组件实例的所有指令都被解除绑定，所有事件侦听器都被移除，所有子组件实例被卸载。</p><hr><h2 id="连环问：如何正确的操作-DOM"><a href="#连环问：如何正确的操作-DOM" class="headerlink" title="连环问：如何正确的操作 DOM"></a>连环问：如何正确的操作 DOM</h2><p><code>mounted</code> 和 <code>updated</code> 都不会保证所有子组件都挂载完成，如果想等待所有视图都渲染完成，需要使用 <code>$nextTick</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.$nextTick(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 仅在整个视图都被渲染之后才会运行的代码</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连环问：ajax-放在哪个生命周期合适？"><a href="#连环问：ajax-放在哪个生命周期合适？" class="headerlink" title="连环问：ajax 放在哪个生命周期合适？"></a>连环问：ajax 放在哪个生命周期合适？</h2><p>一般有两个选择：<code>created</code> 和 <code>mounted</code> ，建议选择后者 <code>mounted</code> 。</p><p>执行速度</p><ul><li>从理论上来说，放在 <code>created</code> 确实会快一些</li><li>但 ajax 是网络请求，其时间是主要的影响因素。从 <code>created</code> 到 <code>mounted</code> 是 JS 执行，速度非常快。</li><li>所以，两者在执行速度上不会有肉眼可见的差距</li></ul><p>代码的阅读和理解</p><ul><li>放在 <code>created</code> 却会带来一些沟通和理解成本，从代码的执行上来看，它会一边执行组件渲染，一边触发网络请求，并行</li><li>放在 <code>mounted</code> 就是等待 DOM 渲染完成再执行网络请求，串行，好理解</li></ul><p>所以，综合来看，更建议选择 <code>mounted</code> 。</p><h2 id="连环问：Composition-API-生命周期有何不同"><a href="#连环问：Composition-API-生命周期有何不同" class="headerlink" title="连环问：Composition API 生命周期有何不同"></a>连环问：Composition API 生命周期有何不同</h2><ul><li><code>setup</code> 代替了 <code>beforeCreate</code> 和 <code>created</code></li><li>生命周期换成了函数的形式，如 <code>mounted</code> -&gt; <code>onMounted</code> 参考 <a href="https://v3.cn.vuejs.org/api/composition-api.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90">https://v3.cn.vuejs.org/api/composition-api.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onUpdated, onMounted &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="title function_">setup</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">onMounted</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="title function_">onUpdated</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="父子生命周期流程"><a href="#父子生命周期流程" class="headerlink" title="父子生命周期流程"></a>父子生命周期流程</h2><h4 id="加载渲染过程"><a href="#加载渲染过程" class="headerlink" title="加载渲染过程"></a>加载渲染过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</span><br></pre></td></tr></table></figure><h4 id="更新过程"><a href="#更新过程" class="headerlink" title="更新过程"></a>更新过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</span><br></pre></td></tr></table></figure><h4 id="销毁过程"><a href="#销毁过程" class="headerlink" title="销毁过程"></a>销毁过程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父beforeDestroy-&gt;子beforeDestroy-&gt;子destroyed-&gt;父destroyed</span><br></pre></td></tr></table></figure><hr><h2 id="Vue-优化"><a href="#Vue-优化" class="headerlink" title="Vue 优化"></a>Vue 优化</h2><ul><li>v-if 和 v-show</li><li>v-for 使用 key</li><li>computed 缓存</li><li>keep-alive</li><li>异步组件</li><li>路由懒加载</li><li>SSR</li></ul><h2 id="Vue遇到的坑"><a href="#Vue遇到的坑" class="headerlink" title="Vue遇到的坑"></a>Vue遇到的坑</h2><p>全局事件、自定义事件要在组件销毁时解除绑定</p><ul><li>内存泄漏风险</li><li>全局事件（如 <code>window.resize</code>）不解除，则会继续监听，而且组件再次创建时会重复绑定</li></ul><p>Vue2.x 中，无法监听 data 属性的新增和删除，以及数组的部分修改 —— Vue3 不会有这个问题</p><ul><li>新增 data 属性，需要用 <code>Vue.set</code></li><li>删除 data 属性，需要用 <code>Vue.delete</code></li><li>修改数组某一元素，不能 <code>arr[index] = value</code> ，要使用 <code>arr.splice</code> API 方式</li></ul><p>路由切换时，页面会 scroll 到顶部。例如，在一个新闻列表页下滑到一定位置，点击进入详情页，在返回列表页，此时会 scroll 到顶部，并重新渲染列表页。所有的 SPA 都会有这个问题，并不仅仅是 Vue 。</p><ul><li>在列表页缓存数据和 <code>scrollTop</code></li><li>返回列表页时（用 Vue-router <a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">导航守卫</a>，判断 <code>from</code>），使用缓存数据渲染页面，然后 <code>scrollTo(scrollTop)</code></li></ul><hr><h2 id="Vue-错误监听"><a href="#Vue-错误监听" class="headerlink" title="Vue 错误监听"></a>Vue 错误监听</h2><ul><li><p>window.onerror</p></li><li><p>errorCaptured 生命周期</p><p>会监听所有<strong>下级组件</strong>的错误。可以返回 <code>false</code> 阻止向上传播，因为可能会有多个上级节点都监听错误。</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">errorCaptured</span>(<span class="params">error, instance, info</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;errorCaptured--------&#x27;</span>, error, instance, info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>errorHandler</li></ul><p>全局的错误监听，所有组件的报错都会汇总到这里来。PS：如果 <code>errorCaptured</code> 返回 <code>false</code> 则<strong>不会</strong>到这里。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="title function_">createApp</span>(<span class="title class_">App</span>)</span><br><span class="line">app.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="function">(<span class="params">error, instance, info</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;errorHandler--------&#x27;</span>, error, instance, info)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，<code>errorHandler</code> 会阻止错误走向 <code>window.onerror</code>。</p><ul><li>Promise 监听报错要使用 <code>window.onunhandledrejection</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vue-生命周期&quot;&gt;&lt;a href=&quot;#vue-生命周期&quot; class=&quot;headerlink&quot; title=&quot;vue 生命周期&quot;&gt;&lt;/a&gt;vue 生命周期&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/vue-%E7%94%9F%E5%91%BD%E5%91</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>前端基础</title>
    <link href="https://github.com/zheng521/2023/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/"/>
    <id>https://github.com/zheng521/2023/04/04/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</id>
    <published>2023-04-04T14:14:21.000Z</published>
    <updated>2023-04-06T06:27:14.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="箭头函数的缺点"><a href="#箭头函数的缺点" class="headerlink" title="箭头函数的缺点"></a>箭头函数的缺点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>什么时候不能使用箭头函数？</p><h2 id="箭头函数的缺点-1"><a href="#箭头函数的缺点-1" class="headerlink" title="箭头函数的缺点"></a>箭头函数的缺点</h2><p>没有 arguments</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">arguments</span>) <span class="comment">// 报错，arguments is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn1</span>(<span class="number">100</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>无法通过 call apply bind 等改变 this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">fn1</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line">fn1.<span class="title function_">call</span>(&#123; <span class="attr">x</span>: <span class="number">100</span> &#125;)</span><br></pre></td></tr></table></figure><p>简写的函数会变得难以阅读</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">multiply</span> = (<span class="params">a, b</span>) =&gt; b === <span class="literal">undefined</span> ? <span class="function"><span class="params">b</span> =&gt;</span> a * b : a * b</span><br></pre></td></tr></table></figure><h2 id="不适用箭头函数的场景"><a href="#不适用箭头函数的场景" class="headerlink" title="不适用箭头函数的场景"></a>不适用箭头函数的场景</h2><p>对象方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span>,</span><br><span class="line">    <span class="attr">getName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="title function_">getName</span>() )</span><br></pre></td></tr></table></figure><p>扩展对象原型（包括构造函数的原型）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">__proto__</span>.<span class="property">getName</span> = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>( obj.<span class="title function_">getName</span>() )</span><br></pre></td></tr></table></figure><p>构造函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Foo</span> = (<span class="params">name, age</span>) =&gt; &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>) <span class="comment">// 报错 Foo is not a constructor</span></span><br></pre></td></tr></table></figure><p>动态上下文中的回调函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> btn1 = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn1&#x27;</span>)</span><br><span class="line">btn1.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="function">() =&gt;</span> &#123;  </span><br><span class="line">    <span class="comment">// console.log(this === window)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">innerHTML</span> = <span class="string">&#x27;clicked&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue 生命周期和方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="title function_">data</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> &#123; <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span> &#125; &#125;,</span><br><span class="line">    <span class="attr">methods</span>: &#123;</span><br><span class="line">        <span class="attr">getName</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 报错 Cannot read properties of undefined (reading &#x27;name&#x27;)</span></span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// getName() &#123;</span></span><br><span class="line">        <span class="comment">//     return this.name // 正常</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mounted</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 报错 Cannot read properties of undefined (reading &#x27;name&#x27;)</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;msg&#x27;</span>, <span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// mounted() &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;msg&#x27;, this.name) // 正常</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【注意】class 中使用箭头函数则<strong>没问题</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">    getName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;张三&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getName&#x27;</span>, f.<span class="title function_">getName</span>())</span><br></pre></td></tr></table></figure><p>所以，在 React 中可以使用箭头函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">onClick</span>=<span class="string">&#123;this.printName&#125;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    printName = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>箭头函数的缺点</p><ul><li>arguments 参数</li><li>无法改变 this</li></ul><p>不适用的场景</p><ul><li>对象方法</li><li>对象原型</li><li>构造函数</li><li>动态上下文</li><li>Vue 生命周期和方法</li></ul><hr><h1 id="for…in-和-for…of-的区别"><a href="#for…in-和-for…of-的区别" class="headerlink" title="for…in 和 for…of 的区别"></a>for…in 和 for…of 的区别</h1><h1 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h1><p>for…in 和 for…of 的区别</p><h2 id="key-和-value"><a href="#key-和-value" class="headerlink" title="key 和 value"></a>key 和 value</h2><p>for…in 遍历 key , for…of 遍历 value</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> s <span class="keyword">of</span> str) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> argument <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(argument) <span class="comment">// for...of 可以获取 value ，而 for...in 获取 key</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pList = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> pList) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(p) <span class="comment">// for...of 可以获取 value ，而 for...in 获取 key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历对象"><a href="#遍历对象" class="headerlink" title="遍历对象"></a>遍历对象</h2><p>for…in 可以遍历对象，for…of 不可以</p><h2 id="遍历-Map-x2F-Set"><a href="#遍历-Map-x2F-Set" class="headerlink" title="遍历 Map&#x2F;Set"></a>遍历 Map&#x2F;Set</h2><p>for…of 可以遍历 Map&#x2F;Set ，for…in 不可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> set1) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> map1 = <span class="keyword">new</span> <span class="title class_">Map</span>([</span><br><span class="line">    [<span class="string">&#x27;x&#x27;</span>, <span class="number">10</span>], [<span class="string">&#x27;y&#x27;</span>, <span class="number">20</span>], [<span class="string">&#x27;z&#x27;</span>, <span class="number">3</span>]</span><br><span class="line">])</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> map1) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历-generator"><a href="#遍历-generator" class="headerlink" title="遍历 generator"></a>遍历 generator</h2><p>for…of 可遍历 generator ，for…in 不可以</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">10</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">20</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">30</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> o <span class="keyword">of</span> <span class="title function_">foo</span>()) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(o)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的可枚举属性"><a href="#对象的可枚举属性" class="headerlink" title="对象的可枚举属性"></a>对象的可枚举属性</h2><p>for…in 遍历一个对象的可枚举属性。</p><p>使用 <code>Object.getOwnPropertyDescriptors(obj)</code> 可以获取对象的所有属性描述，看 <code> enumerable: true</code> 来判断该属性是否可枚举。</p><p>对象，数组，字符传</p><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>for…of 遍历一个可迭代对象。<br><br>其实就是迭代器模式，通过一个 <code>next</code> 方法返回下一个元素。</p><p>该对象要实现一个 <code>[Symbol.iterator]</code> 方法，其中返回一个 <code>next</code> 函数，用于返回下一个 value（不是 key）。<br><br>可以执行 <code>arr[Symbol.iterator]()</code> 看一下。</p><p>JS 中内置迭代器的类型有 <code>String</code> <code>Array</code> <code>arguments</code> <code>NodeList</code> <code>Map</code> <code>Set</code> <code>generator</code> 等。</p><h2 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h2><ul><li>for…in 遍历一个对象的可枚举属性，如对象、数组、字符串。针对属性，所以获得 key</li><li>for…of 遍历一个可迭代对象，如数组、字符串、Map&#x2F;Set 。针对一个迭代对象，所以获得 value</li></ul><h2 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a>划重点</h2><p>“枚举” “迭代” 都是计算机语言的一些基础术语，目前搞不懂也没关系。<br><br>但请一定记住 for…of 和 for…in 的不同表现。</p><h2 id="连环问：for-await…of"><a href="#连环问：for-await…of" class="headerlink" title="连环问：for await…of"></a>连环问：for await…of</h2><p>用于遍历异步请求的可迭代对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 像定义一个创建 promise 的函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createTimeoutPromise</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(val)</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你明确知道有几个 promise 对象，那直接处理即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> p1 = <span class="title function_">createTimeoutPromise</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">const</span> p2 = <span class="title function_">createTimeoutPromise</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> p1</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v1)</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> p2</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v2)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>如果你有一个对象，里面有 N 个 promise 对象，你可以这样处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> list = [</span><br><span class="line">        <span class="title function_">createTimeoutPromise</span>(<span class="number">10</span>),</span><br><span class="line">        <span class="title function_">createTimeoutPromise</span>(<span class="number">20</span>)</span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一，使用 Promise.all 执行</span></span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">all</span>(list).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(res))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二，使用 for await ... of 遍历执行</span></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(p)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，如果用 for...of 只能遍历出各个 promise 对象，而不能触发 await 执行</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>【注意】如果你想顺序执行，只能延迟创建 promise 对象，而不能及早创建。<br><br>即，你创建了 promise 对象，它就立刻开始执行逻辑。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> <span class="title function_">createTimeoutPromise</span>(<span class="number">10</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v1)</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> <span class="title function_">createTimeoutPromise</span>(<span class="number">20</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(v2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> [<span class="number">100</span>, <span class="number">200</span>]) &#123;</span><br><span class="line">        <span class="keyword">const</span> v = <span class="keyword">await</span> <span class="title function_">createTimeoutPromise</span>(n)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;v&#x27;</span>, v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><hr><h1 id="HTMLCollection-和-NodeList-的区别"><a href="#HTMLCollection-和-NodeList-的区别" class="headerlink" title="HTMLCollection 和 NodeList 的区别"></a>HTMLCollection 和 NodeList 的区别</h1><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h2><p>HTMLCollection 和 NodeList 的区别，Node 和 Element 的区别</p><h2 id="Node-和-Element"><a href="#Node-和-Element" class="headerlink" title="Node 和 Element"></a>Node 和 Element</h2><p>DOM 结构是一棵树，树的所有节点都是 <code>Node</code> ，包括：document，元素，文本，注释，fragment 等</p><p><code>Element</code> 继承于 Node 。它是所有 html 元素的基类，如 <code>HTMLParagraphElement</code> <code>HTMLDivElement</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// document</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Node</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DocumentFragment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Node</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文本和注释</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CharacterData</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Node</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Comment</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CharacterData</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Text</span> <span class="keyword">extends</span> <span class="title class_ inherited__">CharacterData</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elem</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Element</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Node</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Element</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLParagraphElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HTMLDivElement</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;&#125;</span><br><span class="line"><span class="comment">// ... 其他 elem ...</span></span><br></pre></td></tr></table></figure><h2 id="HTMLCollection-和-NodeList"><a href="#HTMLCollection-和-NodeList" class="headerlink" title="HTMLCollection 和 NodeList"></a>HTMLCollection 和 NodeList</h2><p>HTMLCollection 是 Element 集合，它由获取 Element 的 API 返回</p><ul><li><code>elem.children</code></li><li><code>document.getElementsByTagName(&#39;p&#39;)</code></li></ul><p>NodeList 是 Node 集合，它由获取 Node 的 API 返回</p><ul><li><code>document.querySelectorAll(&#39;p&#39;)</code></li><li><code>elem.childNodes</code></li></ul><h2 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h2><ul><li>HTMLCollection 是 Element 集合，NodeList 是 Node 集合</li><li>Node 是所有 DOM 节点的基类，Element 是 html 元素的基类</li></ul><h2 id="划重点-1"><a href="#划重点-1" class="headerlink" title="划重点"></a>划重点</h2><p>注意 Node 和 Element 在实际 API 中的区别，如 <code>children</code> 和 <code>childNodes</code> 获取的结果可能是不一样的（如果子节点有 Text 或 Comment）</p><h2 id="扩展：类数组"><a href="#扩展：类数组" class="headerlink" title="扩展：类数组"></a>扩展：类数组</h2><p>HTMLCollection 和 NodeList 都不是数组，而是“类数组”。转换为数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTMLCollection 和 NodeList 都不是数组，而是“类数组”</span></span><br><span class="line"><span class="keyword">const</span> arr1 = <span class="title class_">Array</span>.<span class="title function_">from</span>(list)</span><br><span class="line"><span class="keyword">const</span> arr2 = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">slice</span>.<span class="title function_">call</span>(list)</span><br><span class="line"><span class="keyword">const</span> arr3 = [...list]</span><br></pre></td></tr></table></figure><hr><h1 id="JS-严格模式和非严格模式"><a href="#JS-严格模式和非严格模式" class="headerlink" title="JS 严格模式和非严格模式"></a>JS 严格模式和非严格模式</h1><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>JS 严格模式和非严格模式的区别</p><h2 id="设计初衷"><a href="#设计初衷" class="headerlink" title="设计初衷"></a>设计初衷</h2><p>Javascript 设计之初，有很多不合理、不严谨、不安全之处，例如变量未定义即可使用 <code>n = 100</code>。严格模式用于规避这些问题。</p><p>而现在 ES 规范已经普及，从语法上已经规避了这些问题。</p><h2 id="开启严格模式"><a href="#开启严格模式" class="headerlink" title="开启严格模式"></a>开启严格模式</h2><p>代码（或一个函数）一开始插入一行 <code>&#39;use strict&#39;</code> 即可开启严格模式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span> <span class="comment">// 全局开启</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span> <span class="comment">// 某个函数开启</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，开发环境用 ES 或者 Typescript ，打包出的 js 代码使用严格模式</p><h2 id="严格模式的不同"><a href="#严格模式的不同" class="headerlink" title="严格模式的不同"></a>严格模式的不同</h2><p>严格模式的细则有很多，这里总结一些常用常见的</p><h3 id="全局变量必须声明"><a href="#全局变量必须声明" class="headerlink" title="全局变量必须声明"></a>全局变量必须声明</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line">n = <span class="number">10</span> <span class="comment">// ReferenceError: n is not defined</span></span><br></pre></td></tr></table></figure><h3 id="禁止使用-with"><a href="#禁止使用-with" class="headerlink" title="禁止使用 with"></a>禁止使用 <code>with</code></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;</span><br><span class="line"><span class="keyword">with</span> (obj) &#123;</span><br><span class="line">    <span class="comment">// Uncaught SyntaxError: Strict mode code may not include a with statement</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-eval-作用域"><a href="#创建-eval-作用域" class="headerlink" title="创建 eval 作用域"></a>创建 eval 作用域</h3><p>正常模式下，JS 只有两种变量作用域：全局作用域 + 函数作用域。严格模式下，JS 增加了 eval 作用域。</p><p><strong>chrome 隐私模式下执行这段代码？？？</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;var x = 20; console.log(x)&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x)</span><br></pre></td></tr></table></figure><h3 id="禁止-this-指向全局作用域"><a href="#禁止-this-指向全局作用域" class="headerlink" title="禁止 this 指向全局作用域"></a>禁止 this 指向全局作用域</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure><h3 id="函数参数不能重名"><a href="#函数参数不能重名" class="headerlink" title="函数参数不能重名"></a>函数参数不能重名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, x, y</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h2><ul><li>全局变量必须声明</li><li>禁止使用 with</li><li>创建 eval 作用域</li><li>禁止 this 指向全局作用域</li><li>函数参数不能重名</li></ul><hr><h1 id="options-请求"><a href="#options-请求" class="headerlink" title="options 请求"></a>options 请求</h1><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>跨域为何需要 options 请求？</p><h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>浏览器同源策略，默认限制跨域请求。跨域的解决方案</p><ul><li>jsonp</li><li>CORS</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CORS 配置允许跨域（服务端）</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;http://localhost:8011&quot;</span>) <span class="comment">// 或者 &#x27;*&#x27;</span></span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;X-Requested-With&quot;</span>)</span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;PUT,POST,GET,DELETE,OPTIONS&quot;</span>)</span><br><span class="line">response.<span class="title function_">setHeader</span>(<span class="string">&quot;Access-Control-Allow-Credentials&quot;</span>, <span class="string">&quot;true&quot;</span>) <span class="comment">// 允许跨域接收 cookie</span></span><br></pre></td></tr></table></figure><h2 id="options-请求-1"><a href="#options-请求-1" class="headerlink" title="options 请求"></a>options 请求</h2><p>使用 CORS 跨域请求时，经常会看到一个“多余”的 options 请求，之后才发送了实际的请求。</p><p><img src="/./images/options.png"></p><p>该请求就是为了检查服务端的 headers 信息，是否符合客户端的预期。所以它没有 body 的返回。</p><blockquote><p>规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 OPTIONS 方法发起一个预检请求（preflight request），从而获知服务端是否允许该跨域请求。—— MDN</p></blockquote><h2 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h2><p>options 请求就是对 CORS 跨域请求之间的一次预检查，检查成功再发起正式请求，是浏览器自行处理的。<br><br>了解即可，实际开发中不用过于关注。</p><hr><h2 id="js-原型链"><a href="#js-原型链" class="headerlink" title="js 原型链"></a>js 原型链</h2><p><img src="/images/js%E5%8E%9F%E5%9E%8B%E9%93%BE.png"></p><hr><h2 id="x3D-x3D-比较"><a href="#x3D-x3D-比较" class="headerlink" title="&#x3D;&#x3D; 比较"></a>&#x3D;&#x3D; 比较</h2><p><img src="/images/==%E6%AF%94%E8%BE%83.png"></p><p><img src="/images/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png"></p><hr><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p><img src="/images/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95.png"></p><hr><h2 id="前端首屏加载优化"><a href="#前端首屏加载优化" class="headerlink" title="前端首屏加载优化"></a>前端首屏加载优化</h2><p><img src="/images/%E5%89%8D%E7%AB%AF%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96.png"></p><hr><h2 id="https-加密过程"><a href="#https-加密过程" class="headerlink" title="https 加密过程"></a>https 加密过程</h2><p><img src="/images/https%E5%8A%A0%E5%AF%86.png"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;箭头函数的缺点&quot;&gt;&lt;a href=&quot;#箭头函数的缺点&quot; class=&quot;headerlink&quot; title=&quot;箭头函数的缺点&quot;&gt;&lt;/a&gt;箭头函数的缺点&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>输出什么</title>
    <link href="https://github.com/zheng521/2023/04/04/%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/"/>
    <id>https://github.com/zheng521/2023/04/04/%E8%BE%93%E5%87%BA%E4%BB%80%E4%B9%88/</id>
    <published>2023-04-04T13:49:17.000Z</published>
    <updated>2023-04-04T14:09:57.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p><code>[1,2,3].map(parseInt)</code>输出什么</p><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p><code>parseInt(string, radix)</code> 解析一个字符串并返回指定基数的<strong>十进制</strong>整数</p><ul><li><code>string</code> 要解析的字符串</li><li><code>radix</code> 可选参数，数字基数（即进制），范围为 2-36</li></ul><p>示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;11&#x27;</span>, <span class="number">1</span>) <span class="comment">// NaN ，1 非法，不在 2-36 范围之内</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;11&#x27;</span>, <span class="number">2</span>) <span class="comment">// 3 = 1*2 + 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>) <span class="comment">// NaN ，2 进制中不存在 3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;11&#x27;</span>, <span class="number">3</span>) <span class="comment">// 4 = 1*3 + 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;11&#x27;</span>, <span class="number">8</span>) <span class="comment">// 9 = 1*8 + 1</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;9&#x27;</span>, <span class="number">8</span>) <span class="comment">// NaN ，8 进制中不存在 9</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;11&#x27;</span>, <span class="number">10</span>) <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;A&#x27;</span>, <span class="number">16</span>) <span class="comment">// 10 ，超过 10 进制，个位数就是 1 2 3 4 5 6 7 8 9 A B C D ...</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;F&#x27;</span>, <span class="number">16</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;G&#x27;</span>, <span class="number">16</span>) <span class="comment">// NaN ，16 进制个位数最多是 F ，不存在 G</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1F&#x27;</span>, <span class="number">16</span>) <span class="comment">// 31 = 1*16 + F</span></span><br></pre></td></tr></table></figure><h2 id="radix-x3D-x3D-null-或者-radix-x3D-x3D-x3D-0"><a href="#radix-x3D-x3D-null-或者-radix-x3D-x3D-x3D-0" class="headerlink" title="radix &#x3D;&#x3D; null 或者 radix &#x3D;&#x3D;&#x3D; 0"></a>radix &#x3D;&#x3D; null 或者 radix &#x3D;&#x3D;&#x3D; 0</h2><ul><li>如果 <code>string</code> 以 <code>0x</code> 开头，则按照 16 进制处理，例如 <code>parseInt(&#39;0x1F&#39;)</code> 等同于 <code>parseInt(&#39;1F&#39;, 16)</code></li><li>如果 <code>string</code> 以 <code>0</code> 开头，则按照 8 进制处理 —— <strong>ES5 之后就取消了，改为按 10 进制处理，但不是所有浏览器都这样，一定注意！！！</strong></li><li>其他情况，按 10 进制处理</li></ul><h2 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h2><p>题目代码可以拆解为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]</span><br><span class="line"><span class="keyword">const</span> res = arr.<span class="title function_">map</span>(<span class="function">(<span class="params">s, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`s is <span class="subst">$&#123;s&#125;</span>, index is <span class="subst">$&#123;index&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(s, index)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br></pre></td></tr></table></figure><p>分析执行过程</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>) <span class="comment">// 1 ，radix === 0 按 10 进制处理</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;2&#x27;</span>, <span class="number">1</span>) <span class="comment">// NaN ，radix === 1 非法（不在 2-36 之内）</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&#x27;3&#x27;</span>, <span class="number">2</span>) <span class="comment">// NaN ，2 进制中没有 3</span></span><br></pre></td></tr></table></figure><hr><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><p>以下代码，执行会输出什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>) &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>) &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>) &#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property">a</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>()</span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Foo</span>()</span><br><span class="line">obj.<span class="title function_">a</span>()</span><br><span class="line"><span class="title class_">Foo</span>.<span class="title function_">a</span>()</span><br></pre></td></tr></table></figure><h4 id="解析："><a href="#解析：" class="headerlink" title="解析："></a>解析：</h4><p>执行完new以后,函数执行内部函数体会覆盖原来的函数</p><h4 id="答案：-4-2-1"><a href="#答案：-4-2-1" class="headerlink" title="答案：  4 2 1"></a>答案：  4 2 1</h4><hr><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><p>以下代码，执行会输出什么？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">4</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">5</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="解析：-1"><a href="#解析：-1" class="headerlink" title="解析："></a>解析：</h4><h4 id="then-交替执行"><a href="#then-交替执行" class="headerlink" title="then 交替执行"></a>then 交替执行</h4><p>如果有多个 fulfilled 状态的 promise 实例，同时执行 then 链式调用，then 会交替调用<br><br>这是编译器的优化，防止一个 promise 持续占据事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">20</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">30</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">40</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">100</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">200</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">300</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">400</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="then-返回-promise-对象"><a href="#then-返回-promise-对象" class="headerlink" title="then 返回 promise 对象"></a>then 返回 promise 对象</h2><p>当 then 返回 promise 对象时，可以认为是多出一个 promise 实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">100</span>) <span class="comment">// 相当于多处一个 promise 实例，如下注释的代码</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">200</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">300</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">300</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">20</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">30</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">40</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 相当于新增一个 promise 实例 —— 但这个执行结果不一样，后面解释</span></span><br><span class="line"><span class="comment">// Promise.resolve(100).then(res =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(res)</span></span><br><span class="line"><span class="comment">// &#125;).then(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(200)</span></span><br><span class="line"><span class="comment">// &#125;).then(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(300)</span></span><br><span class="line"><span class="comment">// &#125;).then(() =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     console.log(400)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br></pre></td></tr></table></figure><h2 id="“慢两拍”"><a href="#“慢两拍”" class="headerlink" title="“慢两拍”"></a>“慢两拍”</h2><p>then 返回 promise 实例和直接执行 <code>Promise.resolve()</code> 不一样，它需要等待两个过程</p><ul><li>promise 状态由 pending 变为 fulfilled</li><li>then 函数挂载到 microTaskQueue</li></ul><p>所以，它变现的会“慢两拍”。可以理解为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">10</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">20</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">30</span>)</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">40</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 第一拍</span></span><br><span class="line">    <span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="number">100</span>)</span><br><span class="line">    <span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 第二拍</span></span><br><span class="line">        p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(res)</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">200</span>)</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">300</span>)</span><br><span class="line">        &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">400</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>题目代码输出的结果是 <code>1 2 3 4 5 6</code></p><hr><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h2><p>React 中以下代码会输出什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">super</span>()</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">val</span>: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="comment">// this.state.val 初始值是 0 </span></span><br><span class="line"></span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">val</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span> + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span>) <span class="comment">//0</span></span><br><span class="line">  </span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">val</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span> + <span class="number">1</span>&#125;)</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span>) <span class="comment">//0</span></span><br><span class="line">  </span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">val</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span> + <span class="number">1</span>&#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span>) <span class="comment">// 2</span></span><br><span class="line">  </span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">val</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span> + <span class="number">1</span>&#125;)</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span>) <span class="comment">// 3</span></span><br><span class="line">      &#125;, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.state.val&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setState-默认异步更新"><a href="#setState-默认异步更新" class="headerlink" title="setState 默认异步更新"></a>setState 默认异步更新</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">val</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span> + <span class="number">1</span>&#125;, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数可以拿到最新值</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;callback&#x27;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span>) <span class="comment">// 拿不到最新值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setState-默认会合并"><a href="#setState-默认会合并" class="headerlink" title="setState 默认会合并"></a>setState 默认会合并</h2><p>多次执行，最后 render 结果还是 <code>1</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">val</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span> + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">val</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span> + <span class="number">1</span>&#125;)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">val</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">val</span> + <span class="number">1</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="setState-有时同步更新"><a href="#setState-有时同步更新" class="headerlink" title="setState 有时同步更新"></a>setState 有时同步更新</h2><p>根据 <code>setState</code> 的<strong>触发时机是否受 React 控制</strong></p><p>如果触发时机在 React 所控制的范围之内，则<strong>异步更新</strong></p><ul><li>生命周期内触发</li><li>React JSX 事件内触发</li></ul><p>如果触发时机不在 React 所控制的范围之内，则<strong>同步更新</strong></p><ul><li>setTimeout setInterval</li><li>自定义的 DOM 事件</li><li>Promise then</li><li>ajax 网络请求回调</li></ul><h2 id="setState-有时不会合并"><a href="#setState-有时不会合并" class="headerlink" title="setState 有时不会合并"></a>setState 有时不会合并</h2><p>第一，同步更新，不会合并</p><p>第二，传入函数，不会合并 （对象可以 <code>Object.assign</code>，函数无法合并）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">val</span>: prevState.<span class="property">val</span> + <span class="number">1</span> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h2><p>题目代码执行打印 <code>0 0 2 3</code></p><hr><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h2><p>以下代码，运行会输出什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line">a.<span class="property">x</span> = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">x</span>) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b.<span class="property">x</span>)</span><br></pre></td></tr></table></figure><h2 id="值类型-vs-引用类型"><a href="#值类型-vs-引用类型" class="headerlink" title="值类型 vs 引用类型"></a>值类型 vs 引用类型</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">100</span></span><br><span class="line"><span class="keyword">let</span> b = a</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> b = a</span><br></pre></td></tr></table></figure><p><img src="/./img/%E5%A0%86%E6%A0%88.png"></p><h2 id="连续赋值"><a href="#连续赋值" class="headerlink" title="连续赋值"></a>连续赋值</h2><p>连续赋值是倒序执行。PS：日常工作不可用连续赋值，可读性差</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n1, n2</span><br><span class="line">n1 = n2 = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// // 相当于</span></span><br><span class="line"><span class="comment">// n2 = 100</span></span><br><span class="line"><span class="comment">// n1 = n2</span></span><br></pre></td></tr></table></figure><h2 id="优先级更高"><a href="#优先级更高" class="headerlink" title=". 优先级更高"></a><code>.</code> 优先级更高</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">a.<span class="property">x</span> = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可拆解为：</span></span><br><span class="line"><span class="comment">// 1. a.x = undefined // 初始化 a.x 属性</span></span><br><span class="line"><span class="comment">// 2. a.x = 100 // 为 x 属性赋值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再看下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">n</span>: <span class="number">1</span> &#125;</span><br><span class="line">a.<span class="property">x</span> = a = &#123; <span class="attr">n</span>: <span class="number">2</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// // 可以拆解为</span></span><br><span class="line"><span class="comment">// a.x = undefined</span></span><br><span class="line"><span class="comment">// let x = a.x // x 变量是假想的，实际执行时不会有</span></span><br><span class="line"><span class="comment">// x = a = &#123; n: 2 &#125;</span></span><br></pre></td></tr></table></figure><p><img src="/./img/%E5%A0%86%E6%A0%882.png"></p><h2 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h2><p>题目代码执行打印 <code>undefined</code> 和 <code>&#123; n: 2 &#125;</code></p><hr><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h2><p>执行以下代码，会输出什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example1</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;, b = <span class="string">&#x27;123&#x27;</span>, c = <span class="number">123</span></span><br><span class="line">a[b] = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">a[c] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b])</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 2</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;, b = <span class="title class_">Symbol</span>(<span class="string">&#x27;123&#x27;</span>), c = <span class="title class_">Symbol</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">a[b] = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">a[c] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b])</span><br><span class="line"></span><br><span class="line"><span class="comment">// example 3</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;, b = &#123; <span class="attr">key</span>:<span class="string">&#x27;123&#x27;</span> &#125;, c = &#123; <span class="attr">key</span>:<span class="string">&#x27;456&#x27;</span> &#125;</span><br><span class="line">a[b] = <span class="string">&#x27;b&#x27;</span></span><br><span class="line">a[c] = <span class="string">&#x27;c&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a[b])</span><br></pre></td></tr></table></figure><h2 id="对象的-key"><a href="#对象的-key" class="headerlink" title="对象的 key"></a>对象的 key</h2><ul><li>对象的键名只能是字符串和 Symbol 类型</li><li>其他类型的键名会被转换成字符串类型</li><li>对象转字符串默认会调用 <code>toString</code> 方法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">obj[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> x = &#123; <span class="attr">s</span>: <span class="string">&#x27;abc&#x27;</span> &#125;</span><br><span class="line">obj[x] = <span class="number">200</span></span><br><span class="line"><span class="keyword">const</span> y = <span class="title class_">Symbol</span>()</span><br><span class="line">obj[y] = <span class="number">300</span></span><br><span class="line"><span class="keyword">const</span> z = <span class="literal">true</span></span><br><span class="line">obj[z] = <span class="number">400</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(obj) <span class="comment">// [&#x27;0&#x27;, &#x27;[object Object]&#x27;, &#x27;true&#x27;]</span></span><br></pre></td></tr></table></figure><p>有些类数组的结构是 <code>&#123; 0: x, 1: y, 2: z, length: 3 &#125;</code> ，如 <code>document.getElementsByTagName(&#39;div&#39;)</code><br><br>实际上它的 key 是 <code>[&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;length&#39;]</code></p><h2 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h2><h2 id="题目代码执行分别打印-39-c-39-39-b-39-39-c-39"><a href="#题目代码执行分别打印-39-c-39-39-b-39-39-c-39" class="headerlink" title="题目代码执行分别打印 &#39;c&#39; &#39;b&#39; &#39;c&#39;"></a>题目代码执行分别打印 <code>&#39;c&#39; &#39;b&#39; &#39;c&#39;</code></h2><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h2><p>运行以下代码，会输出什么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">changeArg</span>(<span class="params">x</span>) &#123; x = <span class="number">200</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> num = <span class="number">100</span></span><br><span class="line"><span class="title function_">changeArg</span>(num)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;changeArg num&#x27;</span>, num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;双越&#x27;</span> &#125;</span><br><span class="line"><span class="title function_">changeArg</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;changeArg obj&#x27;</span>, obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeArgProp</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    x.<span class="property">name</span> = <span class="string">&#x27;张三&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">changeArgProp</span>(obj)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;changeArgProp obj&#x27;</span>, obj)</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>调用函数，传递参数 —— <strong>赋值</strong>传递</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="comment">// 继续操作 x y</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;双越&#x27;</span> &#125;</span><br><span class="line"><span class="title function_">fn</span>(num, obj)</span><br></pre></td></tr></table></figure><p>以上代码相当于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> num = <span class="number">100</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;双越&#x27;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = num</span><br><span class="line"><span class="keyword">let</span> y = obj</span><br><span class="line"><span class="comment">// 继续操作 x y</span></span><br></pre></td></tr></table></figure><h2 id="解题"><a href="#解题" class="headerlink" title="解题"></a>解题</h2><p>执行题目代码分别输出 <code>100  &#123;name: &#39;双越&#39;&#125;  &#123;name: &#39;张三&#39;&#125;</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h3&gt;&lt;p&gt;&lt;code&gt;[1,2,3].map(parseInt)&lt;/code&gt;输出什么&lt;/p&gt;
&lt;h4 id=&quot;解析&quot;&gt;&lt;a href=&quot;#解析&quot; c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>面试高频代码</title>
    <link href="https://github.com/zheng521/2023/04/02/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/zheng521/2023/04/02/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E4%BB%A3%E7%A0%81/</id>
    <published>2023-04-02T03:43:23.000Z</published>
    <updated>2023-04-07T05:43:44.667Z</updated>
    
    <content type="html"><![CDATA[<h3 id="遍历节点生成虚拟Dom"><a href="#遍历节点生成虚拟Dom" class="headerlink" title="遍历节点生成虚拟Dom"></a>遍历节点生成虚拟Dom</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vnode</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">tag, data, value, type</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tag</span> = tag  &amp;&amp; tag.<span class="title function_">toLowerCass</span>()</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">value</span> = value </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = type </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span> = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">appendChild</span>(<span class="params">vnode</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">children</span>.<span class="title function_">push</span>(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createVnode</span>(<span class="params">node</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> nodeType = node.<span class="property">type</span> </span><br><span class="line">  <span class="keyword">let</span> _vnode = <span class="literal">null</span> </span><br><span class="line">  <span class="keyword">if</span> (nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> tagName = node.<span class="property">nodeName</span> </span><br><span class="line">    <span class="keyword">const</span> attrList = node.<span class="property">attributes</span></span><br><span class="line">    <span class="keyword">const</span> attrData = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; attrList.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      attrData[attrList[i].<span class="property">nodeName</span>] = attrList[i].<span class="property">nodeName</span></span><br><span class="line">    &#125; </span><br><span class="line">    _vnode = <span class="keyword">new</span> <span class="title class_">Vnode</span>(tagName, attrData, <span class="literal">null</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> childNodes = node.<span class="property">childNodes</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childNodes.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      _vnode.<span class="title function_">appendChild</span>(<span class="title function_">createVnode</span>(childNodes[i]))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeType === <span class="number">3</span>) &#123;</span><br><span class="line">    _vnode = <span class="keyword">new</span> <span class="title class_">Vnode</span>(<span class="literal">null</span>, node.<span class="property">nodeValue</span>, value, <span class="number">3</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过虚拟dom生成真实节点"><a href="#通过虚拟dom生成真实节点" class="headerlink" title="通过虚拟dom生成真实节点"></a>通过虚拟dom生成真实节点</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">getRealNode</span>(<span class="params">vnode</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; tag, data, value, type, children &#125; = vnode</span><br><span class="line">  <span class="keyword">let</span> _node = <span class="literal">null</span> </span><br><span class="line">  <span class="keyword">if</span> (type === <span class="number">1</span>) &#123;</span><br><span class="line">    _node = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(tag)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">      _node.<span class="title function_">setAttribute</span>(key, data[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      _node.<span class="title function_">appendChild</span>(<span class="title function_">getRealNode</span>(children[i]))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type === <span class="number">3</span>) &#123;</span><br><span class="line">    _node = <span class="variable language_">document</span>.<span class="title function_">createTextNode</span>(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="千分位格式话"><a href="#千分位格式话" class="headerlink" title="千分位格式话"></a>千分位格式话</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">format</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = n.<span class="title function_">toString</span>()</span><br><span class="line">  <span class="keyword">let</span> arr = str.<span class="title function_">split</span>(<span class="string">&#x27;&#x27;</span>).<span class="title function_">reverse</span>()</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index % <span class="number">3</span> === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (prev) &#123;</span><br><span class="line">        <span class="keyword">return</span> cur + <span class="string">&#x27;,&#x27;</span> + prev</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cur</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cur + prev</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lazy-man"><a href="#Lazy-man" class="headerlink" title="Lazy man"></a>Lazy man</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LazyMan</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span> (name) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tasks</span> = []</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">next</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  eat (foodName) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">fn</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 吃了 <span class="subst">$&#123;foodName&#125;</span>`</span>)</span><br><span class="line">      <span class="variable language_">this</span>.<span class="title function_">next</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(fn)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  sleep (time) &#123;</span><br><span class="line">    <span class="keyword">const</span> fn = () &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;<span class="variable language_">this</span>.name&#125;</span> 睡了<span class="subst">$&#123;time&#125;</span>长时间`</span>)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">next</span>()</span><br><span class="line">      &#125;, time * <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">push</span>(fn)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  next () &#123;</span><br><span class="line">    <span class="keyword">let</span> fn = <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">tasks</span>.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="arrayToTree-数组构建树形结构数据"><a href="#arrayToTree-数组构建树形结构数据" class="headerlink" title="arrayToTree 数组构建树形结构数据"></a>arrayToTree 数组构建树形结构数据</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数组转树形结构</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">array</span>&#125; list 被转换的数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &#123;<span class="type">number|string</span>&#125; root 根节点（最外层节点）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@returns</span> <span class="variable">array</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">arrayToTree</span>(<span class="params">list, root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> list) &#123;</span><br><span class="line">    map[item.<span class="property">parentId</span>] = item</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> list) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.<span class="property">parentId</span> === root) &#123;</span><br><span class="line">      result.<span class="title function_">push</span>(map[item.<span class="property">id</span>])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      map[item.<span class="property">parentId</span>].<span class="property">children</span> = map[item.<span class="property">parentId</span>].<span class="property">children</span> ? map[item.<span class="property">parentId</span>].<span class="title function_">push</span>(map[item.<span class="property">id</span>]) :</span><br><span class="line">      (map[parent_id].<span class="property">children</span> = [map[id]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flattern"><a href="#flattern" class="headerlink" title="flattern"></a>flattern</h3><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myFlattern</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">prev, cur</span>) =&gt;</span> prev.<span class="title function_">concat</span>(<span class="title class_">Array</span>.<span class="title function_">isArray</span>(cur) ? <span class="title function_">myFlattern</span>(cur): </span><br><span class="line">  cur),[])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;遍历节点生成虚拟Dom&quot;&gt;&lt;a href=&quot;#遍历节点生成虚拟Dom&quot; class=&quot;headerlink&quot; title=&quot;遍历节点生成虚拟Dom&quot;&gt;&lt;/a&gt;遍历节点生成虚拟Dom&lt;/h3&gt;&lt;hr&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;ta</summary>
      
    
    
    
    
    <category term="interview" scheme="https://github.com/zheng521/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>必会手写代码(js基础)</title>
    <link href="https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</id>
    <published>2023-04-01T04:33:14.000Z</published>
    <updated>2023-04-04T14:07:36.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-实现"><a href="#new-实现" class="headerlink" title="new 实现"></a>new 实现</h3><hr><ol><li>创建一个新对象</li><li>将新对象的原型属性指向构造函数的原型对象</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象 (判断新对象是否为对象)</li></ol><p>  &#96;&#96;</p><pre><code>function myNew(Func) &#123;  let obj = &#123;&#125;  obj._prop_ = Func.prototype   let result = Func.apply(obj, arguments)  return  result instanceof Object ? result : obj&#125;</code></pre><h3 id="instaceof-实现"><a href="#instaceof-实现" class="headerlink" title="instaceof 实现"></a>instaceof 实现</h3><hr><pre><code>function myInstaceOf(left, right) &#123;  let prop = Object.getPrototypeOf(left)  let prototype = right.prototype  while (true) &#123;    if (prop === null) return false     if (prop === prototype) &#123;      return true    &#125;    prop = Object.getPrototypeOf(prop)  &#125;&#125;</code></pre><h3 id="call-实现"><a href="#call-实现" class="headerlink" title="call 实现"></a>call 实现</h3><hr><pre><code>function myCall(context) &#123;  context = context || window   context.fn = this   let args = [...arguments].slice(1)  let result = context.fn(...args)  delete context.fn  return result&#125;</code></pre><h3 id="apply实现"><a href="#apply实现" class="headerlink" title="apply实现"></a>apply实现</h3><hr><pre><code>function myApply(content) &#123;  context = context || window   context.fn = this   let result   if (arguments[1]) &#123;    result = context.fn(...arguments[1])  &#125; else &#123;    result = context.fn()  &#125;  return result&#125;</code></pre><h3 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h3><hr><pre><code>function myBind(context) &#123;  let self = this   let args = [...arguments].slice(1)  return function () &#123;    let newArgs = [...arguments]    return self.apply(context, args.concat(newArgs))  &#125;&#125;</code></pre><h3 id="currry实现"><a href="#currry实现" class="headerlink" title="currry实现"></a>currry实现</h3><hr><pre><code>function curry(fn, ...args) &#123;  if (args.length &gt; fn.length) &#123;    fn(...args)  &#125; else &#123;    return (..._args) =&gt; curry(fn, ...args, ..._args)  &#125;&#125;</code></pre><h3 id="compose实现"><a href="#compose实现" class="headerlink" title="compose实现"></a>compose实现</h3><hr><pre><code>const compose = (...fns) =&gt; val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val);function compose (...fns) &#123;  return val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val)&#125;</code></pre><h3 id="pipe实现"><a href="#pipe实现" class="headerlink" title="pipe实现"></a>pipe实现</h3><hr><pre><code>const pipe = (...fns) =&gt; val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val);function compose (...fns) &#123;  return val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val)&#125;</code></pre><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><hr><pre><code>function throttle(fn, delay) &#123;  let timer = null  return function (...args) &#123;    if (!timer) &#123;      timer = setTimeout(() =&gt; &#123;        fn.apply(this, args)        clearTimeout(timer)      &#125;, delay)    &#125;  &#125;&#125;</code></pre><h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h3><hr><pre><code>function debounce(fn, time) &#123;  let timer = null   return function (...args) &#123;    if (timer) clearTimeout(timer)    timer = setTimeout(() =&gt; &#123;      fn.apply(this, args)    &#125;, time)  &#125;&#125;</code></pre><h3 id="object-Freeze-实现"><a href="#object-Freeze-实现" class="headerlink" title="object.Freeze 实现"></a>object.Freeze 实现</h3><hr><pre><code>  function myFreeze(obj) &#123;    if (obj instanceof Object) &#123;      //封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置      Object.seal(obj)      for (let p in obj) &#123;        if (obj.hasOwnProperty(p)) &#123;          Object.defineProperty(obj, p, &#123;writable: false&#125;)          myFreeze(obj[p])        &#125;      &#125;    &#125;  &#125;</code></pre><h3 id="deepcopy"><a href="#deepcopy" class="headerlink" title="deepcopy"></a>deepcopy</h3><hr><pre><code>  function deepCopy(target, map = new WeakMap()) &#123;    if (typeof(target) !== &#39;object&#39;) &#123;      return     &#125;    if (map.get(target)) return map.get(target)    let newObj = Array.isArray(target) ? [] : &#123;&#125;    map.set(target, newObj)    for (let key in target) &#123;      if (targe.hasOwnProperty(key)) &#123;        if (typeof(key) === &#39;object&#39;) &#123;          newObj[key] = deepCopy(target[key])        &#125; else &#123;          newObj[key] = target[key]        &#125;      &#125;    &#125;    return newObj  &#125;</code></pre><h3 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><hr><pre><code>//语法 array.reduce(function(prev, currentValue, currentIndex, arr), initialValue)function myReduce(func, initVal) &#123;  let arr = this   let base = initVal ? initVal : arr[0]  let startPoint = initVal ? 1 : 0   arr.slice(startPoint).forEach((val, index) =&gt; &#123;    let base = func(base, val, index+startPoint, arr)  &#125;)  return base&#125;</code></pre><h3 id="map-实现"><a href="#map-实现" class="headerlink" title="map 实现"></a>map 实现</h3><hr><pre><code>function myMap(fn, thisArg = []) &#123;  return this.reduce((prev, cur, index, arr) =&gt; &#123;    return prev.concat(fn.call(thisArg, cur, index, arr))  &#125;, [])&#125;</code></pre><h3 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h3><hr><pre><code>  const PENDING = &#39;pending&#39;  const FULFILLED = &#39;fulfilled&#39;  const REJECT = &#39;reject&#39;  class Promise &#123;    constructor () &#123;      this.staus = PENDING      this.value = &#39;&#39;      this.reason = &#39;&#39;      this.onResolvedCallBack = []      this.onRejectedCallBack = []      let resolve = (value) =&gt; &#123;        if (this.status === PENDING) &#123;          this.status = FULFILLED           this.value = value          this.onResolvedCallBack.forEach(fn =&gt; fn())        &#125;      &#125;       let reject = (reason) =&gt; &#123;        if (this.status === PENDING) &#123;          this.status = REJECT           this.reason = reason          this.onRejectedCallBack.forEach(fn =&gt; fn())        &#125;      &#125;      try &#123;        exector(resolve, reject)      &#125; catch(err) &#123;        reject(err)      &#125;    &#125;    then(onFulfilled, onRejected) &#123;      if (this.status === FULFIllED) &#123;        onFulfilled(this.value)      &#125;      if (this.status === REJECT) &#123;        onRejected(this.reason)      &#125;      if (this.status === PENDING) &#123;        this.onResolvedCallBack.push(() =&gt; onFulfilled(this.value))        this.onRejectedCallBack.push(() =&gt; onRejected(this.reason))      &#125;    &#125;  &#125;  </code></pre><h3 id="promiseAll"><a href="#promiseAll" class="headerlink" title="promiseAll"></a>promiseAll</h3><hr><pre><code>function promiseAll(promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let result = []    let count = 0     promises.forEach((promise, index) =&gt; &#123;      promise.then(res =&gt; &#123;        result.push(res)        count++        if (count === promises.length) &#123;          resolve(result)        &#125;      &#125;, err =&gt; reject(err))    &#125;)  &#125;)&#125;</code></pre><h3 id="promiseFinally"><a href="#promiseFinally" class="headerlink" title="promiseFinally"></a>promiseFinally</h3><hr><pre><code>function promiseFinally(cb) &#123;  return this.then(value =&gt; &#123;    return Promise.resolve(cb()).then(() =&gt; value)  &#125;, err =&gt; &#123;    return Promise.resolve(cb()).then(() =&gt; err)  &#125;)&#125;</code></pre><h3 id="promiseAllSetted"><a href="#promiseAllSetted" class="headerlink" title="promiseAllSetted"></a>promiseAllSetted</h3><hr><pre><code>function promiseAllSetted(promises) &#123;  _promises = promises.map(item =&gt; item instanceof Promise ? item : Promise.resolve(item))  return new Promise((resolve, reject) =&gt; &#123;    let result = []    let unSettedCount = _promise.length    _promises.forEach((promise, index) =&gt; &#123;      promise.then(res =&gt; &#123;        result[index] = &#123;          status: &#39;fulfilled&#39;,           res        &#125;        unSettedCount--        unSettedCount === 0 &amp;&amp; resolve(result)      &#125;, err =&gt; &#123;        result[index] = &#123;          status: &#39;reject&#39;,           err        &#125;        unSettedCount--        unSettedCount === 0 &amp;&amp; reject(result)      &#125;)    &#125;)  &#125;)&#125;</code></pre><h3 id="promiseRace"><a href="#promiseRace" class="headerlink" title="promiseRace"></a>promiseRace</h3><hr><pre><code>function promiseRace(promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    promises.forEach(promise =&gt; &#123;      promise.then(res =&gt; resolve(res), err =&gt; reject(err))    &#125;)  &#125;)&#125;</code></pre><h3 id="promiseAny"><a href="#promiseAny" class="headerlink" title="promiseAny"></a>promiseAny</h3><hr><pre><code>function promiseAny(promises) &#123;  return new Promise((resolve, reject) =&gt; &#123;    let count = 0     promises.forEach(promise =&gt; &#123;      promise.then(res =&gt; &#123;        resolve(res)      &#125;, err =&gt; &#123;        count++         count === promises.length &amp;&amp; reject(err)      &#125;)    &#125;)  &#125;)&#125;</code></pre><h3 id="async-x2F-await-自动执行器"><a href="#async-x2F-await-自动执行器" class="headerlink" title="async&#x2F;await  自动执行器"></a>async&#x2F;await  自动执行器</h3><hr><pre><code>  function runGenerator(gen) &#123;    return new Promise((resolve, reject) =&gt; &#123;      let g = gen()      function _next() &#123;        let res        try &#123;          res = g.next(val)        &#125; catch(err) &#123;          return reject(err)        &#125;        if (res.done) &#123;          return resolve(res.value)        &#125;        //res.value包装为promise，以兼容yield后面跟基本类型的情况        Promise.resolve(res.value).then(val =&gt; &#123;          _next(val)        &#125;, err =&gt; &#123;          g.throw(err)        &#125;)      &#125;      _next()    &#125;)  &#125;</code></pre><h3 id="JSON-stringify-实现"><a href="#JSON-stringify-实现" class="headerlink" title="JSON.stringify 实现"></a>JSON.stringify 实现</h3><hr><pre><code>function jsonStringify(data) &#123;  let type = typeof data;  if(type !== &#39;object&#39;) &#123;    let result = data;    //data 可能是基础数据类型的情况在这里处理    if (Number.isNaN(data) || data === Infinity) &#123;      //NaN 和 Infinity 序列化返回 &quot;null&quot;      result = &quot;null&quot;;    &#125; else if (type === &#39;function&#39; || type === &#39;undefined&#39; || type === &#39;symbol&#39;) &#123;      // 由于 function 序列化返回 undefined，因此和 undefined、symbol 一起处理      return undefined;    &#125; else if (type === &#39;string&#39;) &#123;      result = &#39;&quot;&#39; + data + &#39;&quot;&#39;;    &#125;    return String(result);  &#125; else if (type === &#39;object&#39;) &#123;    if (data === null) &#123;        return &quot;null&quot;  // 第01讲有讲过 typeof null 为&#39;object&#39;的特殊情况    &#125; else if (data.toJSON &amp;&amp; typeof data.toJSON === &#39;function&#39;) &#123;        return jsonStringify(data.toJSON());    &#125; else if (data instanceof Array) &#123;        let result = [];        //如果是数组，那么数组里面的每一项类型又有可能是多样的        data.forEach((item, index) =&gt; &#123;        if (typeof item === &#39;undefined&#39; || typeof item === &#39;function&#39; || typeof item === &#39;symbol&#39;) &#123;              result[index] = &quot;null&quot;;          &#125; else &#123;              result[index] = jsonStringify(item);          &#125;        &#125;);        result = &quot;[&quot; + result + &quot;]&quot;;        return result.replace(/&#39;/g, &#39;&quot;&#39;);      &#125; else &#123;        // 处理普通对象        let result = [];        Object.keys(data).forEach((item, index) =&gt; &#123;            if (typeof item !== &#39;symbol&#39;) &#123;              //key 如果是 symbol 对象，忽略              if (data[item] !== undefined &amp;&amp; typeof data[item] !== &#39;function&#39; &amp;&amp; typeof data[item] !== &#39;symbol&#39;) &#123;                //键值如果是 undefined、function、symbol 为属性值，忽略                result.push(&#39;&quot;&#39; + item + &#39;&quot;&#39; + &quot;:&quot; + jsonStringify(data[item]));              &#125;            &#125;        &#125;);        return (&quot;&#123;&quot; + result + &quot;&#125;&quot;).replace(/&#39;/g, &#39;&quot;&#39;);        &#125;    &#125;&#125;</code></pre><h3 id="JSON-parse-实现"><a href="#JSON-parse-实现" class="headerlink" title="JSON.parse 实现"></a>JSON.parse 实现</h3><hr><pre><code>var json = &#39;&#123;&quot;a&quot;:&quot;1&quot;, &quot;b&quot;:2&#125;&#39;;// obj 就是 json 反序列化之后得到的对象var obj = eval(&quot;(&quot; + json + &quot;)&quot;); </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-实现&quot;&gt;&lt;a href=&quot;#new-实现&quot; class=&quot;headerlink&quot; title=&quot;new 实现&quot;&gt;&lt;/a&gt;new 实现&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新对象&lt;/li&gt;
&lt;li&gt;将新对象的原型属性指向构造函数的原型对象&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="interview" scheme="https://github.com/zheng521/tags/interview/"/>
    
  </entry>
  
</feed>
