<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>初见</title>
  
  
  <link href="https://github.com/zheng521/atom.xml" rel="self"/>
  
  <link href="https://github.com/zheng521/"/>
  <updated>2023-04-01T07:15:41.725Z</updated>
  <id>https://github.com/zheng521/</id>
  
  <author>
    <name>zheng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>必会手写代码</title>
    <link href="https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"/>
    <id>https://github.com/zheng521/2023/04/01/%E5%BF%85%E4%BC%9A%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/</id>
    <published>2023-04-01T04:33:14.000Z</published>
    <updated>2023-04-01T07:15:41.725Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-实现"><a href="#new-实现" class="headerlink" title="new 实现"></a>new 实现</h3><hr><ol><li>创建一个新对象</li><li>将新对象的原型属性指向构造函数的原型对象</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li><li>执行构造函数中的代码（为这个新对象添加属性）</li><li>返回新对象 (判断新对象是否为对象)</li></ol><p>  &#96;&#96;</p><pre><code>function myNew(Func) &#123;  let obj = &#123;&#125;  obj._prop_ = Func.prototype   let result = Func.apply(obj, arguments)  return  result instanceof Object ? result : obj&#125;</code></pre><h3 id="instaceof-实现"><a href="#instaceof-实现" class="headerlink" title="instaceof 实现"></a>instaceof 实现</h3><hr><pre><code>function myInstaceOf(left, right) &#123;  let prop = Object.getPrototypeOf(left)  let prototype = right.prototype  while (true) &#123;    if (prop === null) return false     if (prop === prototype) &#123;      return true    &#125;    prop = Object.getPrototypeOf(prop)  &#125;&#125;</code></pre><h3 id="call-实现"><a href="#call-实现" class="headerlink" title="call 实现"></a>call 实现</h3><hr><pre><code>function myCall(context) &#123;  context = context || window   context.fn = this   let args = [...arguments].slice(1)  let result = context.fn(...args)  delete context.fn  return result&#125;</code></pre><h3 id="apply实现"><a href="#apply实现" class="headerlink" title="apply实现"></a>apply实现</h3><hr><pre><code>function myApply(content) &#123;  context = context || window   context.fn = this   let result   if (arguments[1]) &#123;    result = context.fn(...arguments[1])  &#125; else &#123;    result = context.fn()  &#125;  return result&#125;</code></pre><h3 id="bind实现"><a href="#bind实现" class="headerlink" title="bind实现"></a>bind实现</h3><hr><pre><code>function myBind(context) &#123;  let self = this   let args = [...arguments].slice(1)  return function () &#123;    let newArgs = [...arguments]    return self.apply(context, args.concat(newArgs))  &#125;&#125;</code></pre><h3 id="currry实现"><a href="#currry实现" class="headerlink" title="currry实现"></a>currry实现</h3><hr><pre><code>function curry(fn, ...args) &#123;  if (args.length &gt; fn.length) &#123;    fn(...args)  &#125; else &#123;    return (..._args) =&gt; curry(fn, ...args, ..._args)  &#125;&#125;</code></pre><h3 id="compose实现"><a href="#compose实现" class="headerlink" title="compose实现"></a>compose实现</h3><hr><pre><code>const compose = (...fns) =&gt; val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val);function compose (...fns) &#123;  return val =&gt; fns.reverse().reduce((acc, fn) =&gt; fn(acc), val)&#125;</code></pre><h3 id="pipe实现"><a href="#pipe实现" class="headerlink" title="pipe实现"></a>pipe实现</h3><hr><pre><code>const pipe = (...fns) =&gt; val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val);function compose (...fns) &#123;  return val =&gt; fns.reduce((acc, fn) =&gt; fn(acc), val)&#125;</code></pre><h3 id="throttle"><a href="#throttle" class="headerlink" title="throttle"></a>throttle</h3><hr><pre><code>function throttle(fn, delay) &#123;  let timer = null  return function (...args) &#123;    if (!timer) &#123;      timer = setTimeout(() =&gt; &#123;        fn.apply(this, args)        clearTimeout(timer)      &#125;, delay)    &#125;  &#125;&#125;</code></pre><h3 id="debounce"><a href="#debounce" class="headerlink" title="debounce"></a>debounce</h3><hr><pre><code>function debounce(fn, time) &#123;  let timer = null   return function (...args) &#123;    if (timer) clearTimeout(timer)    timer = setTimeout(() =&gt; &#123;      fn.apply(this, args)    &#125;, time)  &#125;&#125;</code></pre><h3 id="object-Freeze-实现"><a href="#object-Freeze-实现" class="headerlink" title="object.Freeze 实现"></a>object.Freeze 实现</h3><hr><pre><code>  function myFreeze(obj) &#123;    if (obj instanceof Object) &#123;      //封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置      Object.seal(obj)      for (let p in obj) &#123;        if (obj.hasOwnProperty(p)) &#123;          Object.defineProperty(obj, p, &#123;writable: false&#125;)          myFreeze(obj[p])        &#125;      &#125;    &#125;  &#125;</code></pre><h3 id="deepcopy"><a href="#deepcopy" class="headerlink" title="deepcopy"></a>deepcopy</h3><hr><pre><code>  function deepCopy(target, map = new WeakMap()) &#123;    if (typeof(target) !== &#39;object&#39;) &#123;      return     &#125;    if (map.get(target)) return map.get(target)    let newObj = Array.isArray(target) ? [] : &#123;&#125;    map.set(target, newObj)    for (let key in target) &#123;      if (targe.hasOwnProperty(key)) &#123;        if (typeof(key) === &#39;object&#39;) &#123;          newObj[key] = deepCopy(target[key])        &#125; else &#123;          newObj[key] = target[key]        &#125;      &#125;    &#125;    return newObj  &#125;</code></pre><h3 id="arrayToTree-数组构建树形结构数据"><a href="#arrayToTree-数组构建树形结构数据" class="headerlink" title="arrayToTree 数组构建树形结构数据"></a>arrayToTree 数组构建树形结构数据</h3><pre><code>/**   * 数组转树形结构   * @param &#123;array&#125; list 被转换的数组   * @param &#123;number|string&#125; root 根节点（最外层节点）   * @returns array   */function arrayToTree(list, root) &#123;  let map = &#123;&#125;  for (let item of list) &#123;    map[item.parentId] = item  &#125;  let result = []  for (let item of list) &#123;    if (item.parentId === root) &#123;      result.push(map[item.id])    &#125; else &#123;      map[item.parentId].children = map[item.parentId].children ? map[item.parentId].push(map[item.id]) :      (map[parent_id].children = [map[id]])    &#125;  &#125;  return result&#125;</code></pre><h3 id="flattern"><a href="#flattern" class="headerlink" title="flattern"></a>flattern</h3><hr><pre><code>function myFlattern(arr) &#123;  return arr.reduce((prev, cur) =&gt; prev.concat(Array.isArray(cur) ? myFlattern(cur):   cur),[])&#125;</code></pre><h3 id="reduce-实现"><a href="#reduce-实现" class="headerlink" title="reduce 实现"></a>reduce 实现</h3><hr><pre><code>//语法 array.reduce(function(prev, currentValue, currentIndex, arr), initialValue)function myReduce(func, initVal) &#123;  let arr = this   let base = initVal ? initVal : arr[0]  let startPoint = initVal ? 1 : 0   arr.slice(startPoint).forEach((val, index) =&gt; &#123;    let base = func(base, val, index+startPoint, arr)  &#125;)  return base&#125;</code></pre><h3 id="map-实现"><a href="#map-实现" class="headerlink" title="map 实现"></a>map 实现</h3><hr><pre><code>function myMap(fn, thisArg = []) &#123;  return this.reduce((prev, cur, index, arr) =&gt; &#123;    return prev.concat(fn.call(thisArg, cur, index, arr))  &#125;, [])&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-实现&quot;&gt;&lt;a href=&quot;#new-实现&quot; class=&quot;headerlink&quot; title=&quot;new 实现&quot;&gt;&lt;/a&gt;new 实现&lt;/h3&gt;&lt;hr&gt;
&lt;ol&gt;
&lt;li&gt;创建一个新对象&lt;/li&gt;
&lt;li&gt;将新对象的原型属性指向构造函数的原型对象&lt;/li&gt;
</summary>
      
    
    
    
    
    <category term="interview" scheme="https://github.com/zheng521/tags/interview/"/>
    
  </entry>
  
</feed>
